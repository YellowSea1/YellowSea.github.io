<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>利用Hexo+github搭建个人博客</title>
    <url>/2021/12/28/blog/%E5%88%A9%E7%94%A8Hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="利用Hexo-github搭建个人博客"><a href="#利用Hexo-github搭建个人博客" class="headerlink" title="利用Hexo+github搭建个人博客"></a>利用Hexo+github搭建个人博客</h1><h2 id="1-搭建博客需要的工具"><a href="#1-搭建博客需要的工具" class="headerlink" title="1.搭建博客需要的工具"></a>1.搭建博客需要的工具</h2><h3 id="1-1安装node-js"><a href="#1-1安装node-js" class="headerlink" title="1.1安装node.js"></a>1.1安装node.js</h3><p>参考教程：<a href="https://space.bilibili.com/13282871/video">https://space.bilibili.com/13282871/video</a></p>
<p>安装完成后检查node.js以及下面的npm是否安装成功</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20211219173436125.png" alt="image-20211219173436125"></p>
<h3 id="1-2安装git"><a href="#1-2安装git" class="headerlink" title="1.2安装git"></a>1.2安装git</h3><p>安装完成后检查是否安装成功</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20211219173507543.png" alt="image-20211219173507543"></p>
<h3 id="1-3Hexo下载"><a href="#1-3Hexo下载" class="headerlink" title="1.3Hexo下载"></a>1.3Hexo下载</h3><p><code>npm install hexo-cli -g</code></p>
<p>检查是否安装成功</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20211219173641891.png" alt="image-20211219173641891"></p>
<h2 id="2-创建github仓库"><a href="#2-创建github仓库" class="headerlink" title="2.创建github仓库"></a>2.创建github仓库</h2><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20211219175114837.png" alt="image-20211219175114837"></p>
<p>命名格式必须是：注册名.github.io</p>
<h2 id="3-生成SSH-Keys"><a href="#3-生成SSH-Keys" class="headerlink" title="3.生成SSH Keys"></a>3.生成SSH Keys</h2><p>进入任意一个目录，调出git bash</p>
<p>生成ssh私钥和公钥 <code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20211221005037405.png" alt="image-20211221005037405"></p>
<p>一直enter就行</p>
<p>找到生成的公钥，一般在 C:\Users[account] .ssh 目录下id_rsa.pub文件,[account]是主机的用户名</p>
<p>将公钥添加至github</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20211221005431677.png" alt="image-20211221005431677"></p>
<p> 检查公钥是否添加成功 <code>ssh -T git@github.com</code></p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20211221005519439.png" alt="image-20211221005519439"></p>
<h2 id="4-本地生成博客内容"><a href="#4-本地生成博客内容" class="headerlink" title="4.本地生成博客内容"></a>4.本地生成博客内容</h2><p>本地新建一个目录用于存放博客</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init <span class="comment">#初始化博客</span></span><br><span class="line">hexo g <span class="comment">#生成博客</span></span><br><span class="line">hexo s<span class="comment">#启动博客</span></span><br></pre></td></tr></table></figure>

<p>博客启动后本地访问网址</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20211221100125779.png" alt="image-20211221100125779"></p>
<p>本地页面部署成功</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20211221100558152.png" alt="image-20211221100558152"></p>
<h2 id="5-发布博客到互联网"><a href="#5-发布博客到互联网" class="headerlink" title="5.发布博客到互联网"></a>5.发布博客到互联网</h2><p>修改配置文件 _config.yml(在根目录下)</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20211222153449132.png" alt="image-20211222153449132"></p>
<p>安装插件并将博客上传到gitee</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>此时需要登录github，登陆完之后自动上传</p>
<p>仓库setting中可以找到博客访问路径</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20211222155203143.png" alt="image-20211222155203143"></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>hexo butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法|时间复杂度|动态数组|哈希表</title>
    <url>/2021/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>几种应用场景：</p>
<ul>
<li><strong>有序数组</strong>中找到num</li>
<li><strong>有序数组</strong>中找到&gt;=num最左的位置</li>
<li><strong>有序数组</strong>中找到&lt;=num最右的位置</li>
<li>局部最小值问题</li>
</ul>
<h3 id="1-有序数组中找到num"><a href="#1-有序数组中找到num" class="headerlink" title="1.有序数组中找到num"></a>1.有序数组中找到num</h3><h3 id="2-有序数组中找到-gt-num最左的位置"><a href="#2-有序数组中找到-gt-num最左的位置" class="headerlink" title="2.有序数组中找到&gt;=num最左的位置"></a>2.<strong>有序数组</strong>中找到&gt;=num最左的位置</h3><p>array[mid]&lt;num 舍去左边部分，改变左边界L=mid+1</p>
<p>array[mid]&gt;=num 舍去右边部分，改变右边界R=mid-1  //等号在这里，舍去靠右的index  <strong>易错</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mostLeftNoLessNumIndex</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span> || array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> midValue=array[mid];</span><br><span class="line">            <span class="keyword">if</span> (midValue &lt; num) &#123;</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//array[mid]&gt;num</span></span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-有序数组中找到-lt-num最右的位置"><a href="#3-有序数组中找到-lt-num最右的位置" class="headerlink" title="3.有序数组中找到&lt;=num最右的位置"></a>3.<strong>有序数组</strong>中找到&lt;=num最右的位置</h3><p>array[mid]&lt;=num舍去左边部分，改变左边界L=mid+1 //等号在这里，舍去靠左的index <strong>易错</strong></p>
<p>array[mid]&gt;num 舍去右边部分，改变右边界R=mid-1 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mostRightNoMoreIndex</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span> || array == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[mid] &lt;= num) &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//array[mid]&gt;num</span></span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-局部最小值问题"><a href="#4-局部最小值问题" class="headerlink" title="4.局部最小值问题"></a>4.局部最小值问题</h3><p>条件：数组是无序的，且相邻数不相等</p>
<p>分析思路：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="分析思路"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arr 整体无序</span></span><br><span class="line">	<span class="comment">// arr 相邻的数不相等！</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">oneMinIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> N = arr.length;</span><br><span class="line">		<span class="keyword">if</span> (N == <span class="number">1</span>) &#123; <span class="comment">//容易遗漏的边界条件</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (arr[N - <span class="number">1</span>] &lt; arr[N - <span class="number">2</span>]) &#123;</span><br><span class="line">			<span class="keyword">return</span> N - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> R = N - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// L...R 肯定有局部最小</span></span><br><span class="line">		<span class="keyword">while</span> (L &lt; R - <span class="number">1</span>) &#123;  <span class="comment">// L-R至少有三个数,否则mid-1会溢出</span></span><br><span class="line">			<span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (arr[mid] &lt; arr[mid - <span class="number">1</span>] &amp;&amp; arr[mid] &lt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="keyword">return</span> mid;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">					R = mid - <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123; <span class="comment">// arr[mid]&lt;arr[mid-1]</span></span><br><span class="line">					L = mid + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[L] &lt; arr[R] ? L : R;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>二分不一定需要有序，在某一个标准下，只要确定某一侧肯定有，就可以二分</p>
</blockquote>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>在算法函数中，数据量很大时最高阶项算法和时间的关系；</p>
<p>要假设最差情况，才是算法的时间复杂度。</p>
<h3 id="常见时间复杂度列表-（略）"><a href="#常见时间复杂度列表-（略）" class="headerlink" title="常见时间复杂度列表 （略）"></a>常见时间复杂度列表 （略）</h3><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>ArrayList</p>
<p>扩容代价：数组扩容n个数(扩容操作：扩容、拷贝，算法函数是等比数列)，时间复杂度为O(n)，均摊到每次扩容，时间复杂度为O(n)/n=1，很小，<strong>可以忽略不计</strong>；<strong>故动态数组的优点是，从时间复杂度来说，和固定数组性能相差不大，还可以动态扩容。</strong></p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220103194317735.png" alt="扩容过程"></p>
<h2 id="哈希表和有序表"><a href="#哈希表和有序表" class="headerlink" title="哈希表和有序表"></a>哈希表和有序表</h2><h3 id="哈希表-HashMap"><a href="#哈希表-HashMap" class="headerlink" title="哈希表   HashMap()"></a>哈希表   HashMap()</h3><ol>
<li><p>增删查改操作时间复杂度都是常数级别，但是时间略长</p>
</li>
<li><p>基本数据类型按值传递，自定义类型按引用传递；即基本数据类型在哈希表中存储的是值本身，自定义的类型在哈希表中存储的是引用；哈希表的基本数据类型在比较时会比较值，自定义类型会比较引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本数据类型按值传递</span></span><br><span class="line">String test1 = <span class="string">&quot;zuochengyun&quot;</span>;</span><br><span class="line">String test2 = <span class="string">&quot;zuochengyun&quot;</span>;</span><br><span class="line">System.out.println(map.containsKey(test1)); <span class="comment">//输出true</span></span><br><span class="line">System.out.println(map.containsKey(test2)); <span class="comment">//输出false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的类型按引用传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">			value = v;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">Node node2 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">HashMap&lt;Node, String&gt; map3 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map3.put(node1, <span class="string">&quot;我进来了！&quot;</span>);</span><br><span class="line">System.out.println(map3.containsKey(node1)); <span class="comment">//输出true</span></span><br><span class="line">System.out.println(map3.containsKey(node2)); <span class="comment">//输出false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="有序表-TreeMap"><a href="#有序表-TreeMap" class="headerlink" title="有序表  TreeMap()"></a>有序表  TreeMap()</h3><ol>
<li><p>键必须是可比较的(基本数据类型的键都可以比较)</p>
</li>
<li><p>一些常用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Integer,String&gt; treeMap=<span class="keyword">new</span> treeMap&lt;&gt;();</span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">treeMap.put(<span class="number">0</span>,<span class="string">&quot;我是0&quot;</span>);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">treeMap.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">treeMap.get(<span class="number">0</span>); <span class="comment">//输出：我是0</span></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">treeMap.put(<span class="number">0</span>,<span class="string">&quot;我是1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最小的key</span></span><br><span class="line">treeMap.firstKey();</span><br><span class="line"><span class="comment">//获取最大的key</span></span><br><span class="line">treeMap.lastKey();</span><br><span class="line"><span class="comment">//获取&lt;=num最近的key</span></span><br><span class="line">treeMap.floorKey(num);</span><br><span class="line"><span class="comment">//获取&gt;=num最近的key</span></span><br><span class="line">treeMap.cellingKey(num);</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二分法 时间复杂度 动态数组 哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树题目</title>
    <url>/2021/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="1-二叉树按层遍历并收集节点"><a href="#1-二叉树按层遍历并收集节点" class="headerlink" title="1.二叉树按层遍历并收集节点"></a>1.二叉树按层遍历并收集节点</h3><p><a href="https://leetcode.com/problems/balanced-binary-tree">https://leetcode.com/problems/balanced-binary-tree</a></p>
<p><strong>如何顺序收集每层节点的list？</strong></p>
<p>(1) 使用队列收集每一层的节点（队列可以用arrayList或LinkedList实现)</p>
<p>(2) 收集队列的size，size为第三步执行的次数</p>
<p>(3) 弹出节点，先加左节点，有右节点再加右节点</p>
<p><strong>如何逆序？</strong></p>
<p>(1) 如果使用arrayList？首尾交换将链表顺序倒转；<strong>速度慢</strong></p>
<p>(2) 如果使用LinkList?不需要交换，直接加入链表即可；<strong>速度快</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//使用LinkdList储存链表list</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; curAns = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">//不可以直接调用queue.size,队列的size是动态变化的</span></span><br><span class="line">                TreeNode curNode = queue.poll();</span><br><span class="line">                curAns.add(curNode.val);</span><br><span class="line">                <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(curNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(curNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(<span class="number">0</span>, curAns); <span class="comment">//从index=0的地方加入，如果不指定index直接使用ans.add(curAns),默认从最后一个index加入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于栈结构：</strong></p>
<p>java中的Stack类型速度较慢，最快的是使用数组结构实现栈</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220113113044339.png" alt="image-20220113113044339"></p>
<h3 id="2-判断是否是平衡二叉树"><a href="#2-判断是否是平衡二叉树" class="headerlink" title="2.判断是否是平衡二叉树"></a>2.判断是否是平衡二叉树</h3><p> <a href="https://leetcode.com/problems/balanced-binary-tree">https://leetcode.com/problems/balanced-binary-tree</a></p>
<p>每一棵子树左树高度与右数高度高度差&lt;=1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> process(root).isBalanced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以某个节点为头的时候，1)整棵树是否平衡 2)高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isBalanced;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> i, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">		isBalanced = i;</span><br><span class="line">		height = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Info leftInfo = process(root.left);</span><br><span class="line">	Info rightInfo = process(root.right);</span><br><span class="line">	<span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>; <span class="comment">//树的高度:左右任意一棵树高度+1</span></span><br><span class="line">	<span class="keyword">boolean</span> isBalanced = leftInfo.isBalanced &amp;&amp; rightInfo.isBalanced</span><br><span class="line">			&amp;&amp; Math.abs(leftInfo.height - rightInfo.height) &lt; <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-搜索二叉树"><a href="#2-搜索二叉树" class="headerlink" title="2.搜索二叉树"></a>2.搜索二叉树</h3><p>任意一棵子树，左子树节点比头节点小，右子树节点比头节点大</p>
<p><strong>如何判断一棵树是搜索二叉树？</strong></p>
<p>1）中序遍历严格递增</p>
<p>2）递归；左子树是搜索二叉树，且左子树的值小于头节点；右子树是搜索二叉树，右子树节点的值大于头节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">public</span> TreeNode left;</span><br><span class="line">	<span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">	TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isBST;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> is, <span class="keyword">int</span> ma, <span class="keyword">int</span> mi)</span> </span>&#123;</span><br><span class="line">		isBST = is;</span><br><span class="line">		max = ma;</span><br><span class="line">		min = mi;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(TreeNode x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Info leftInfo = process(x.left);</span><br><span class="line">	Info rightInfo = process(x.right);</span><br><span class="line">	<span class="keyword">int</span> max = x.val;</span><br><span class="line">	<span class="keyword">int</span> min = x.val;</span><br><span class="line">	<span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">		max = Math.max(leftInfo.max, max);</span><br><span class="line">		min = Math.min(leftInfo.min, min);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">		max = Math.max(rightInfo.max, max);</span><br><span class="line">		min = Math.min(rightInfo.min, min);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> isBST = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; !leftInfo.isBST) &#123;</span><br><span class="line">		isBST = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rightInfo != <span class="keyword">null</span> &amp;&amp; !rightInfo.isBST) &#123;</span><br><span class="line">		isBST = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 子树是空也是平衡二叉树</span></span><br><span class="line">	<span class="keyword">boolean</span> leftMaxLessX = leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (leftInfo.max &lt; x.val);</span><br><span class="line">	<span class="keyword">boolean</span> rightMinMoreX = rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (rightInfo.min &gt; x.val);</span><br><span class="line">	<span class="keyword">if</span> (!(leftMaxLessX &amp;&amp; rightMinMoreX)) &#123;</span><br><span class="line">		isBST = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(isBST, max, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-能否组成路径和"><a href="#4-能否组成路径和" class="headerlink" title="4.能否组成路径和"></a>4.能否组成路径和</h3><p><a href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">		<span class="keyword">public</span> TreeNode left;</span><br><span class="line">		<span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">		TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">			<span class="keyword">this</span>.val = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isSum = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		isSum = <span class="keyword">false</span>;</span><br><span class="line">		process(root, <span class="number">0</span>, sum);</span><br><span class="line">		<span class="keyword">return</span> isSum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode x, <span class="keyword">int</span> preSum, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x.left == <span class="keyword">null</span> &amp;&amp; x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x.val + preSum == sum) &#123;</span><br><span class="line">				isSum = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// x是非叶节点</span></span><br><span class="line">		preSum += x.val;</span><br><span class="line">		<span class="keyword">if</span> (x.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			process(x.left, preSum, sum);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			process(x.right, preSum, sum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-路径总和"><a href="#5-路径总和" class="headerlink" title="5.路径总和"></a>5.路径总和</h3><p><a href="https://leetcode-cn.com/problems/path-sum-ii/">https://leetcode-cn.com/problems/path-sum-ii/</a></p>
<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(root,path,<span class="number">0</span>,sum,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode x, List&lt;Integer&gt; path, <span class="keyword">int</span> preSum, <span class="keyword">int</span> sum, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span> &amp;&amp; x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preSum + x.val == sum) &#123;</span><br><span class="line">                path.add(x.val);</span><br><span class="line">                List&lt;Integer&gt; ans1 = copy(path);</span><br><span class="line">                ans.add(ans1);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不是叶子节点</span></span><br><span class="line">        path.add(x.val);</span><br><span class="line">        preSum += x.val;</span><br><span class="line">        <span class="keyword">if</span> (x.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            process(x.left, path, preSum, sum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            process(x.right, path, preSum, sum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">copy</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">            list1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>位图、位运算实现加减乘除</title>
    <url>/2021/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BD%8D%E5%9B%BE%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<h2 id="位图、位运算实现加减乘除"><a href="#位图、位运算实现加减乘除" class="headerlink" title="位图、位运算实现加减乘除"></a>位图、位运算实现加减乘除</h2><h3 id="1-位图"><a href="#1-位图" class="headerlink" title="1.位图"></a>1.位图</h3><h4 id="1-1位图的功能"><a href="#1-1位图的功能" class="headerlink" title="1.1位图的功能"></a>1.1位图的功能</h4><p><strong>一个集合，知道一组数的上限和下限，可以通过这个集合收集数字表示这个数字存在或者不存在</strong></p>
<h4 id="1-2位图的好处"><a href="#1-2位图的好处" class="headerlink" title="1.2位图的好处"></a>1.2位图的好处</h4><p><strong>极大地压缩空间；</strong></p>
<p>位图与HashSet用来表示一组数：位图表示一个数可以用1bit,hashSet需要4个字节==&gt;4 * 32bit</p>
<h4 id="1-3位图的实现"><a href="#1-3位图的实现" class="headerlink" title="1.3位图的实现"></a>1.3位图的实现</h4><p>(1)位图用什么来存储？</p>
<p>使用一个long类型的数组存储；每个元素可以表示64个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] bits;</span><br></pre></td></tr></table></figure>

<p>（2）构造函数</p>
<p>需要确定一个数需要多少个元素存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 1.(max + 64) &gt;&gt; 6  ==&gt; (max+64) / 64</span></span><br><span class="line"><span class="comment">			 * 	1.1 max+64:0~63都需要占据一个long</span></span><br><span class="line"><span class="comment">			 * 	1.2 整数右移六位，相当于除以2^6=64</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			bits = <span class="keyword">new</span> <span class="keyword">long</span>[(max + <span class="number">64</span>) &gt;&gt; <span class="number">6</span>];</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>（3）位图添加一个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 	1. num &gt;&gt; 6 ==&gt; num/64</span></span><br><span class="line"><span class="comment">			 * 	2. num &amp; 63 ==&gt; num % 64 ;</span></span><br><span class="line"><span class="comment">			 * 		2.1 num % 64 == num,0&lt;num&lt;63,在二进制中，用0~7位表示即可;两者都是把高于第七位的二进制数归零;</span></span><br><span class="line"><span class="comment">			 * 		2.2 &gt;&gt; &lt;&lt; &amp; | ^ 速度远远大于 + - * /</span></span><br><span class="line"><span class="comment">			 * 	3. 右移运算与或运算</span></span><br><span class="line"><span class="comment">			 * 		3.1 右移：bits数组元素num&gt;&gt;6中num应该标注在第几位</span></span><br><span class="line"><span class="comment">			 * 		3.2 或运算：二进制数与初始的bits[num&gt;&gt;6]相加</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			bits[num &gt;&gt; <span class="number">6</span>] |= (<span class="number">1L</span> &lt;&lt; (num &amp; <span class="number">63</span>));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：一定要与bits[num&gt;&gt;6]进行或运算，否则该元素标志的其他元素将被删除</strong></p>
<p>（4）位图删除一个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 即将相应位数的1归零</span></span><br><span class="line"><span class="comment">			 * 1. &amp;运算：除了相应的位数，其他位都是1，相与即可保持其他位不变，相应位为0</span></span><br><span class="line"><span class="comment">			 * 2. 如何找出这个相与的数？1&lt;&lt;相应位数，然后取反~</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			bits[num &gt;&gt; <span class="number">6</span>] &amp;= ~(<span class="number">1L</span> &lt;&lt; (num &amp; <span class="number">63</span>));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>如何用&amp;运算将相应位置归零?</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220110114559938.png" alt="image-20220110114559938"></p>
<p>如何求出被&amp;的数？ 1&lt;&lt;相应的位数，取反</p>
<p>(5)是否存在某个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 170是否存在？</span></span><br><span class="line"><span class="comment">			 * 1.bits[num &gt;&gt; 6]:找到170所在的元素</span></span><br><span class="line"><span class="comment">			 * 2.1 &lt;&lt; (num &amp; 63):找到170所在的位</span></span><br><span class="line"><span class="comment">			 * 3.相与：00..000100000..（170bits[2]）&amp;bits[2]</span></span><br><span class="line"><span class="comment">			 * 	3.1 170存在：相应位置为1 结果!=0</span></span><br><span class="line"><span class="comment">			 * 	3.2 170不存在：相应位置为1 结果==0</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span> (bits[num &gt;&gt; <span class="number">6</span>] &amp; (<span class="number">1L</span> &lt;&lt; (num &amp; <span class="number">63</span>))) != <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>**1. &gt;&gt;&lt;&lt; &amp; | ^ 速度远远大于 + - * /:**尽量避免使用+、-、*、%，使用，相应操作使用&gt;&gt;、&lt;&lt;、|、&amp;、^代替</p>
<p>​    1.1 num/2^n ==&gt; num&gt;&gt;n  例如num/2^6 ==&gt; num&gt;&gt;6</p>
<p>​    1.2 num%n ==&gt; 1L&lt;&lt;(num&amp;相应的二进制数)</p>
</blockquote>
<h3 id="2-位运算实现加减乘除"><a href="#2-位运算实现加减乘除" class="headerlink" title="2.位运算实现加减乘除"></a>2.位运算实现加减乘除</h3><p>java中加减乘除的底层是位运算，现在自己动手使用位运算编写一个计算器实现加减乘除；虽然说二者都是通过位运算实现，但是java的位运算速度比自己编写的要高一些。</p>
<p>leetcode测试链接：<a href="https://leetcode.com/problems/divide-two-integers">https://leetcode.com/problems/divide-two-integers</a><br>(1)加法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 1.加法 ==&gt; 无进位相加信息+进位信息，直到进位信息为0</span></span><br><span class="line"><span class="comment">			 * 2.^ 异或运算得到无进位相加信息</span></span><br><span class="line"><span class="comment">			 * 3.&amp; 运算之后右移1位：进位信息</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">		<span class="keyword">int</span> sum = a;</span><br><span class="line">		<span class="keyword">while</span> (b != <span class="number">0</span>) &#123; <span class="comment">//直到进位信息为0</span></span><br><span class="line">			sum = a ^ b; <span class="comment">//无进位相加信息 -&gt; sum</span></span><br><span class="line">			b = (a &amp; b) &lt;&lt; <span class="number">1</span>; <span class="comment">//进位信息 -&gt; b -&gt; b&#x27;</span></span><br><span class="line">			a = sum; <span class="comment">//无进位相加信息 a -&gt; a&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>(2)减法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相减</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// a-b==&gt; a+(-b)</span></span><br><span class="line">	<span class="keyword">return</span> add(a, negNum(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)乘法</p>
<p><strong>乘法原理：</strong></p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220110160818108.png" alt="image-20220110160818108"></p>
<p>即数b任意一位为1，则a取全部，否则取0，最后将所有数相加</p>
<p>也可以用下面的方式表示：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220110160442494.png" alt="image-20220110160442494"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="comment">//支持正负a和正负b</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123; <span class="comment">//检查b最末尾一位是否为1</span></span><br><span class="line">			res = add(res, a); <span class="comment">//为1，res添加a;为0，res不添加任何数;  add不和或运算等同，也不和异或运算等同</span></span><br><span class="line">		&#125;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>; <span class="comment">//a左移一位，末端补0</span></span><br><span class="line">		b &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">//b不带符号右移一位，左端补0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)除法</p>
<p>除法运算需要处理被除数或者除数含有系统最小值的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//除法运算</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 *  此方法无法处理含有系统最小值的情况</span></span><br><span class="line"><span class="comment">		 *  0.除法的原理：a/b=c</span></span><br><span class="line"><span class="comment">		 *  	0.1 b*c=a a=c为1的位*b再全部相加</span></span><br><span class="line"><span class="comment">		 *  	0.2 如何找出c为1的位？b左移n位时为&lt;a的最大值，则c的第n位为1</span></span><br><span class="line"><span class="comment">		 *  1.a,b都需要转换成正数x,y</span></span><br><span class="line"><span class="comment">		 *  2.x右移30、29、28...0位</span></span><br><span class="line"><span class="comment">		 *  	！2.1 为什么最多只需要右移30位不是31位？31是符号位，符号位都是0</span></span><br><span class="line"><span class="comment">		 *  3.x右移i位&gt;=y,即可以与y相减</span></span><br><span class="line"><span class="comment">		 *  	3.1记录位数</span></span><br><span class="line"><span class="comment">		 *  	3.2x减去y左移相应位数，剩下的数继续参与循环</span></span><br><span class="line"><span class="comment">		 *		！3.3 为什么是x右移而不是y左移？当x较大时，y左移有可能改变符号位，而x右移则不会出现这种情况；两者的移动位数是一样的</span></span><br><span class="line"><span class="comment">		 *	4.a、b同号？结果为正:结果为负</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *  5.除不尽仍然适用，相当于向下取整：x右移到0仍然没有为0，剩下的值为余数，直接舍弃，相当于向下取整</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> x = isNeg(a) ? negNum(a) : a;</span><br><span class="line">		<span class="keyword">int</span> y = isNeg(b) ? negNum(b) : b;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i = minus(i, <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((x &gt;&gt; i) &gt;= y) &#123;</span><br><span class="line">				res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">				x = minus(x, y &lt;&lt; i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> isNeg(a) ^ isNeg(b) ? negNum(res) : res; <span class="comment">//!=可以用^代替</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//系统最小值的绝对值仍然是最小值本身，所以a或b为系统最小值时需要额外讨论</span></span><br><span class="line">		<span class="keyword">if</span> (a == Integer.MIN_VALUE &amp;&amp; b == Integer.MIN_VALUE) &#123; <span class="comment">//a为最小值或b为最小值时</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == Integer.MIN_VALUE) &#123; <span class="comment">//a不为最小值，b为最小值时</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == Integer.MIN_VALUE) &#123; <span class="comment">//a为最小值，b不为最小值时</span></span><br><span class="line">			<span class="keyword">if</span> (b == negNum(<span class="number">1</span>)) &#123; <span class="comment">//若b为1，系统最小值没有对应的最大值，leetcode规定 Integer.MIN_VALUE/1=Integer/MAX_value;</span></span><br><span class="line">				<span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">//b不为1</span></span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * (a+1)/b=c;</span></span><br><span class="line"><span class="comment">				 * a-c*b=d;</span></span><br><span class="line"><span class="comment">				 * d/b=e;</span></span><br><span class="line"><span class="comment">				 * ans=c+e</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">int</span> c = div(add(a, <span class="number">1</span>), b);</span><br><span class="line">				<span class="keyword">return</span> add(c, div(minus(a, multi(c, b)), b));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> div(a, b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（6）取相反数 判断数是否小于零</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取相反数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">negNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 取反然后+1</span></span><br><span class="line">		<span class="keyword">return</span> add(~n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNeg</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n &lt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二分法 时间复杂度 动态数组 哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表及简单题目</title>
    <url>/2021/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="单链表的反转"><a href="#单链表的反转" class="headerlink" title="单链表的反转"></a>单链表的反转</h2><blockquote>
<p><strong>注意</strong></p>
<p>Jvm的可达性：Jvm会释放掉不可达的内存。–&gt; 链表反转之后需要返回头部，记录头部使链表可达。</p>
</blockquote>
<h3 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h3><h4 id="1-给定一个单链表的头head，完成联表的逆序调整"><a href="#1-给定一个单链表的头head，完成联表的逆序调整" class="headerlink" title="1.给定一个单链表的头head，完成联表的逆序调整"></a>1.给定一个单链表的头head，完成联表的逆序调整</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next; <span class="comment">//next标记当前节点后的链表，防止后续链表丢失</span></span><br><span class="line">            head.next = pre; <span class="comment">//反转指针</span></span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;<span class="comment">//移动pre head</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-给定一个双链表的头head，完成链表的逆序调整"><a href="#2-给定一个双链表的头head，完成链表的逆序调整" class="headerlink" title="2.给定一个双链表的头head，完成链表的逆序调整"></a>2.给定一个双链表的头head，完成链表的逆序调整</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">reverseDoubleList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">     DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">     DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">         next = head.next;<span class="comment">//next标记当前节点后的链表，防止后续链表丢失</span></span><br><span class="line">         head.next = pre;</span><br><span class="line">         head.last = next;<span class="comment">//反转指针</span></span><br><span class="line">         pre = head;</span><br><span class="line">         head = next;<span class="comment">//移动pre head</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> pre;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="用单链表实现队列和栈"><a href="#用单链表实现队列和栈" class="headerlink" title="用单链表实现队列和栈"></a>用单链表实现队列和栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node&lt;V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-用单链表结构实现队列结构"><a href="#1-用单链表结构实现队列结构" class="headerlink" title="1.用单链表结构实现队列结构"></a>1.用单链表结构实现队列结构</h4><p>队列结构先进先出；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> Node&lt;V&gt; head;</span><br><span class="line">       <span class="keyword">private</span> Node&lt;V&gt; tail;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//构造方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           head = <span class="keyword">null</span>;</span><br><span class="line">           tail = <span class="keyword">null</span>;</span><br><span class="line">           size = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//判断是否为空</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//返回队列的长度</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> size;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//入队列</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">           Node&lt;V&gt; cur = <span class="keyword">new</span> Node&lt;&gt;(v);</span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">               head = cur;</span><br><span class="line">               tail = cur;</span><br><span class="line">               size++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               tail.next = cur;</span><br><span class="line">               tail = tail.next;</span><br><span class="line">               size++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//出队列</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> V <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           V ans = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ans = head.value;</span><br><span class="line">               ;</span><br><span class="line">               head = head.next;</span><br><span class="line">               size--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ans;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取队列的长度</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> V <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           V ans = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ans = head.value;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ans;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-用单链表结构实现栈结构"><a href="#2-用单链表结构实现栈结构" class="headerlink" title="2.用单链表结构实现栈结构"></a>2.用单链表结构实现栈结构</h4><p>栈结构后进先出；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">           <span class="keyword">private</span> Node&lt;V&gt; head;</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//构造函数</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               head = <span class="keyword">null</span>;</span><br><span class="line">               size = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//判断是否为空</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//获取栈的长度</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> size;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//入栈</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">               Node&lt;V&gt; cur = <span class="keyword">new</span> Node&lt;&gt;(v);</span><br><span class="line">               <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   head = cur;</span><br><span class="line">                   size++;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   cur.next = head;</span><br><span class="line">                   head = cur;</span><br><span class="line">                   size++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//出栈</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> V <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               V ans = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   ans = head.value;</span><br><span class="line">                   head = head.next;</span><br><span class="line">                   size--;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> ans;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//获取栈顶的值</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> V <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               V ans = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   ans = head.value;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> ans;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 时间复杂度都是O(1)</p>
</blockquote>
<h2 id="用双端链表实现双端队列"><a href="#用双端链表实现双端队列" class="headerlink" title="用双端链表实现双端队列"></a>用双端链表实现双端队列</h2><p>双端队列只能通过双端链表实现</p>
<p>双端队列：可以头进尾出，也可以尾进头出；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//双链表节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;V&gt; last;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双端队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDeque</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;V&gt; head;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;V&gt; tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从头入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushHead</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        Node&lt;V&gt; cur = <span class="keyword">new</span> Node&lt;&gt;(v);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = cur;</span><br><span class="line">            tail = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = head;</span><br><span class="line">            head.last = cur;</span><br><span class="line">            head = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从尾入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushTail</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        Node&lt;V&gt; cur = <span class="keyword">new</span> Node&lt;&gt;(v);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = cur;</span><br><span class="line">            tail = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = cur;</span><br><span class="line">            cur.last = tail;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从头出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">pollHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        V ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = head.value;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123; <span class="comment">//出完最后一个节点，head和tail都为null，如果不手动调整tail的值，会造成脏数据</span></span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            head.last = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从尾出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">pollTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        V ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = tail.value;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail = tail.last;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取头部的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">peekHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        V ans=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ans=head.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取尾部的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V  <span class="title">peekTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        V ans=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ans=tail.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="K个节点组内的逆序调整"><a href="#K个节点组内的逆序调整" class="headerlink" title="K个节点组内的逆序调整"></a>K个节点组内的逆序调整</h2><p>给定一个单链表的头节点，和一个正整数K，实现K个节点的小组内部逆序，如果最后一组不够k个就不调整</p>
<p>例子： 调整前：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8,k=3   调整后：3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;7-&gt;8</p>
<blockquote>
<p>链表考细心，链表不过很容易被pass</p>
</blockquote>
<blockquote>
<p>//leetcode链接：<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode链接：https://leetcode.com/problems/reverse-nodes-in-k-group/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code04_ReverseNodeslnKGroup_01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不要提交评判</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> ListNode next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.找出一组数，start~end;如果剩下的数不够一组，直接返回head</span></span><br><span class="line">        <span class="comment">//2.反转该组数，lastEnd标记该数组的结尾节点start</span></span><br><span class="line">        <span class="comment">//3.根据lastEnd找到下一个start，重复步骤1；如果lastEnd之后没有下一组，结束循环</span></span><br><span class="line">        ListNode start = head;</span><br><span class="line">        ListNode end = getKGroupEnd(start, k);</span><br><span class="line">        <span class="keyword">if</span> (end == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一组凑齐了</span></span><br><span class="line">        head = end;</span><br><span class="line">        reverse(start, end);</span><br><span class="line">        <span class="comment">//上一组的结尾节点</span></span><br><span class="line">        ListNode lastEnd = start;</span><br><span class="line">        <span class="keyword">while</span> (lastEnd.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            start = lastEnd.next;</span><br><span class="line">            end = getKGroupEnd(start, k);</span><br><span class="line">            <span class="keyword">if</span> (end == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(start, end);</span><br><span class="line">            lastEnd.next = end;</span><br><span class="line">            lastEnd = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getKGroupEnd</span><span class="params">(ListNode start, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (--k != <span class="number">0</span> &amp;&amp; start != <span class="keyword">null</span>) &#123;</span><br><span class="line">            start = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode start, ListNode end)</span> </span>&#123;</span><br><span class="line">        end = end.next;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = start;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;  <span class="comment">//cur=cur.ext == cur=pre ×</span></span><br><span class="line">        &#125;</span><br><span class="line">        start.next = end; <span class="comment">//反转后的链表和后面的链表链接，不要忘记！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="两个链表相加"><a href="#两个链表相加" class="headerlink" title="两个链表相加"></a>两个链表相加</h2><p>给定两个链表的头节点head1和head2，认为从左到右是某个数字从低位到高位，返回相加之后的链表</p>
<p>例子  4-&gt;3-&gt;6  2-&gt;5-&gt;3</p>
<p>返回  6-&gt;8-&gt;9</p>
<p>634+352=986</p>
<p>链表相加可以分三个阶段进行，如图所示：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220105204450967.png" alt="链表相加"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = listLength(head1);</span><br><span class="line">        <span class="keyword">int</span> len2 = listLength(head2);</span><br><span class="line">        ListNode l = len1 &gt; len2 ? head1 : head2; <span class="comment">//标记长链</span></span><br><span class="line">        ListNode s = l == head1 ? head2 : head1;  <span class="comment">//标记短链</span></span><br><span class="line">        ListNode curL = l;</span><br><span class="line">        ListNode curS = s;</span><br><span class="line">        ListNode last = curL;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">int</span> curNum = <span class="number">0</span>; <span class="comment">//当前计算结果</span></span><br><span class="line">        <span class="keyword">while</span> (curL != <span class="keyword">null</span>) &#123;  <span class="comment">//第一阶段：长链+短链+进位</span></span><br><span class="line">            curNum = curL.val + curS.val + carry;</span><br><span class="line">            carry = curNum / <span class="number">10</span>;</span><br><span class="line">            curL.val = curNum % <span class="number">10</span>;</span><br><span class="line">            last = curL;</span><br><span class="line">            curL = curL.next;</span><br><span class="line">            curS = curS.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curS != <span class="keyword">null</span>) &#123; <span class="comment">//第二阶段：长链+进位</span></span><br><span class="line">            curNum = curL.val + carry;</span><br><span class="line">            carry = curNum / <span class="number">10</span>;</span><br><span class="line">            curL.val = curNum % <span class="number">10</span>;</span><br><span class="line">            last = curL;</span><br><span class="line">            curL = curL.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123; <span class="comment">//第三阶段：进位</span></span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            last.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">listLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="有序链表合并"><a href="#有序链表合并" class="headerlink" title="有序链表合并"></a>有序链表合并</h2><p>给定两个有序链表的头节点head1和head2，返回合并之后的大链表，要求依然有序。</p>
<p>例子 1-&gt;3-&gt;3-&gt;5-&gt;7  2-&gt;2-&gt;3-&gt;3-&gt;7</p>
<p>返回 1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;3-&gt;5-&gt;7</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 测试链接：https://leetcode.com/problems/merge-two-sorted-lists</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不要提交这个类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> ListNode next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeTwoSortedLinkedList</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;  <span class="comment">//边界条件</span></span><br><span class="line">            <span class="keyword">return</span> head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = head1.val &lt; head2.val ? head1 : head2; <span class="comment">//含有最小值的链表头节点作为合并链表头节点</span></span><br><span class="line">        ListNode cur1 = head.next;</span><br><span class="line">        ListNode cur2 = head == head1 ? head2 : head1;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123; <span class="comment">//依次将当前最小值串联起来</span></span><br><span class="line">            <span class="keyword">if</span> (cur1.val &lt;= cur2.val) &#123; </span><br><span class="line">                pre.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = cur1 == <span class="keyword">null</span> ? cur2 : cur1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>比较器、优先队列、二叉树</title>
    <url>/2021/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><h3 id="1-自定义的比较器"><a href="#1-自定义的比较器" class="headerlink" title="1.自定义的比较器"></a>1.自定义的比较器</h3><p>自定义的类无法通过直接调用Array.sort() / arrList.sort();进行排序，要使用Array.sort()对自定义的类的对象惊醒排序，需要传入一个自定义的比较器。</p>
<p>定义一个自定义的比较器，即需要一个实现<code>Comparator&lt;T&gt;</code>接口的类(T为自定义的类),同时重写compare()方法。</p>
<p>compare()方法返回值的规则：</p>
<blockquote>
<p>1.如果返回负数，认为第一个参数应该排在前面<br>2.如果返回正数，认为第二个参数应该排在前面<br>3.如果返回0，认为谁放前面无所谓</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> String name;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.id = id;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 谁id大，谁放前！</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IdComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果返回负数，认为第一个参数应该排在前面</span></span><br><span class="line">		<span class="comment">// 如果返回正数，认为第二个参数应该排在前面</span></span><br><span class="line">		<span class="comment">// 如果返回0，认为谁放前面无所谓</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (o1.id &lt; o2.id) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o2.id &lt; o1.id) &#123;</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 谁age大，谁放前！</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果返回负数，认为第一个参数应该排在前面</span></span><br><span class="line">		<span class="comment">// 如果返回正数，认为第二个参数应该排在前面</span></span><br><span class="line">		<span class="comment">// 如果返回0，认为谁放前面无所谓</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (o1.age &lt; o2.age) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o2.age &lt; o1.age) &#123;</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个student数组</span></span><br><span class="line">Arrays.sort(students, <span class="keyword">new</span> IdComparator());</span><br><span class="line"><span class="comment">//创建一个student链表</span></span><br><span class="line">arrList.sort(<span class="keyword">new</span> AgeComparator());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-有序结构定义自定义比较器"><a href="#2-有序结构定义自定义比较器" class="headerlink" title="2.有序结构定义自定义比较器"></a>2.有序结构定义自定义比较器</h3><p>优先队列、treeMap、treeSet等有序结构都可以自定义比较器来对自定义的类的对象进行比较。例如优先队列可以调用上面的id比较器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//id大的学生在前</span></span><br><span class="line">PriorityQueue&lt;Student&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> IdComparator());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>优先队列：小根堆，默认值小的对象在前。</p>
</blockquote>
<h3 id="3-字符串如何比较大小？"><a href="#3-字符串如何比较大小？" class="headerlink" title="3.字符串如何比较大小？"></a>3.字符串如何比较大小？</h3><p>所有变成语言中，字符串都是使用<strong>字典序</strong>比较大小的。</p>
<blockquote>
<p><strong>字典序</strong></p>
<p>1.相同长度的字符串：比较每个字符的ASCII码，ACSII码小的字符串较小。</p>
<p>2.不同长度的字符串：较短的字符串使用ASCII码0补全至长度和较长的字符串一致，再根据ACSII码进行比较。</p>
</blockquote>
<h3 id="4-合并K个升序链表"><a href="#4-合并K个升序链表" class="headerlink" title="4.合并K个升序链表"></a>4.合并K个升序链表</h3><p>leetcode链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">https://leetcode-cn.com/problems/merge-k-sorted-lists/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china</a></p>
<ol>
<li>这道题可以使用优先队列来弹出当前的最小值；</li>
<li>要利用这一特性，我们就要创建一个优先队列来存放每个链表的头节点，首先弹出一个最小值作为新链表的头节点，再将弹出节点的下一个节点加入小根堆，直到小根堆里没有节点为止。</li>
<li>优先队列的比较器可以自定义</li>
</ol>
<p><strong>比较器 |优先队列 | 边界条件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code01_MergeKSortedLists</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">		<span class="keyword">public</span> ListNode next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNodeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">ListNode</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.val - o2.val; </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (lists == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> ListNodeComparator());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">			<span class="comment">//边界条件</span></span><br><span class="line">			<span class="keyword">if</span> (lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">				heap.add(lists[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//边界条件</span></span><br><span class="line">		<span class="keyword">if</span> (heap.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//小根堆弹出一个作为返回链表的头节点,进入头节点指向的下一个</span></span><br><span class="line">		ListNode head = heap.poll();</span><br><span class="line">		ListNode pre = head;</span><br><span class="line">		<span class="keyword">if</span> (pre.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">			heap.add(pre.next);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!heap.isEmpty()) &#123; <span class="comment">//直到小根堆为空</span></span><br><span class="line">			<span class="comment">//弹出一个</span></span><br><span class="line">			ListNode cur = heap.poll();</span><br><span class="line">			<span class="comment">//加入链表</span></span><br><span class="line">			pre.next = cur;</span><br><span class="line">			pre = cur;</span><br><span class="line">			<span class="keyword">if</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//加入一个</span></span><br><span class="line">				heap.add(cur.next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1-二叉树不能有环"><a href="#1-二叉树不能有环" class="headerlink" title="1. 二叉树不能有环"></a>1. 二叉树不能有环</h3><h3 id="2-三种遍历方式"><a href="#2-三种遍历方式" class="headerlink" title="2. 三种遍历方式"></a>2. 三种遍历方式</h3><p>(1)先序遍历：头节点，左节点，右节点</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112152349997.png" alt="image-20220112152349997"></p>
<p>(2)中序遍历：左节点、头节点、右节点</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112152447127.png" alt="image-20220112152447127"></p>
<p>(3)后序遍历：左节点、右节点、头节点</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112152524169.png" alt="image-20220112152524169"></p>
<h3 id="3-递归序与先序、中序、后序"><a href="#3-递归序与先序、中序、后序" class="headerlink" title="3. 递归序与先序、中序、后序"></a>3. 递归序与先序、中序、后序</h3><p><strong>递归序：递归程序遍历节点的顺序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一次回到最小树的头节点  在这里System.out.println(head.value),是先序遍历</span></span><br><span class="line">    f(node.left);</span><br><span class="line">    <span class="comment">//第二次回到最小树的头节点  在这里System.out.println(head.value)，是中序遍历</span></span><br><span class="line">    f(node.right);</span><br><span class="line">    <span class="comment">//第三次回到最小树的头节点  在这里System.out.println(head.value)，是后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归程序遍历二叉树①的顺序如图②所示，图③则为其递归序：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112153918244.png" alt="image-20220112153918244"></p>
<p><strong>递归序和先序遍历、中序遍历、后序遍历的结果有什么关系？</strong></p>
<p>先序遍历：数字第一次出现就打印，即小数头节点出现第一次时就打印头节点。</p>
<p>中序遍历：数字第二次出现就打印，即小数头节点出现第二次时就打印头节点。</p>
<p>后序遍历：数字第三次出现就打印，即小数头节点出现第三次时就打印头节点。</p>
<h3 id="4-二叉树的相关题目"><a href="#4-二叉树的相关题目" class="headerlink" title="4.二叉树的相关题目"></a>4.二叉树的相关题目</h3><h5 id="（1）相同的树"><a href="#（1）相同的树" class="headerlink" title="（1）相同的树"></a>（1）相同的树</h5><p>leetcode：<a href="https://leetcode-cn.com/problems/same-tree/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">https://leetcode-cn.com/problems/same-tree/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断是否一棵树为空，另一棵不为空</span></span><br><span class="line">		<span class="keyword">if</span> (p == <span class="keyword">null</span> ^ q == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断两棵树是否都为空</span></span><br><span class="line">		<span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 都不为空</span></span><br><span class="line">		<span class="comment">// 头节点值相同，左子树和右子书分别相同</span></span><br><span class="line">		<span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（2）镜面树"><a href="#（2）镜面树" class="headerlink" title="（2）镜面树"></a>（2）镜面树</h5><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112161107290.png" alt="左节点的左子树和右节点的右子树互为镜面，左节点的右子树和右节点的左子树互为镜面"></p>
<p>leetcode：<a href="https://leetcode.com/problems/symmetric-tree">https://leetcode.com/problems/symmetric-tree</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//头节点自己和自己对比</span></span><br><span class="line">		<span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对比两棵树是否是镜面的</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode h1, TreeNode h2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (h1 == <span class="keyword">null</span> ^ h2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (h1 == <span class="keyword">null</span> &amp;&amp; h2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//两棵树都不为空</span></span><br><span class="line">		<span class="comment">//镜面树：左节点的左子树和右节点的右子树互为镜面，左节点的右子树和右节点的左子树互为镜面</span></span><br><span class="line">		<span class="keyword">return</span> h1.val == h2.val &amp;&amp; isMirror(h1.left, h2.right) &amp;&amp; isMirror(h1.right, h2.left);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-返回树的最大高度"><a href="#3-返回树的最大高度" class="headerlink" title="(3)返回树的最大高度"></a>(3)返回树的最大高度</h5><p>leetcode:<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree">https://leetcode.com/problems/maximum-depth-of-binary-tree</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以root为头的树，最大高度是多少返回！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-通过先序数组和中序数组重建二叉树"><a href="#4-通过先序数组和中序数组重建二叉树" class="headerlink" title="(4)通过先序数组和中序数组重建二叉树"></a>(4)通过先序数组和中序数组重建二叉树</h5><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a></p>
<p><strong>先序数组和中序数组的元素都是不重复的</strong></p>
<p>如何通过先序数组和中序数组重建二叉树？</p>
<p>①先序数组的第一个节点即为头节点；</p>
<p>②在中序数组中找到头节点，左侧的为左子树元素，右侧的为右子树元素；</p>
<p>③先序数组中可以找到对应的左子树元素对应和右子树元素分别对应的区间，区间的第一个元素即为头节点；重复②③步。</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112172926624.png" alt="如何通过先序数组和中序数组重建二叉树？"></p>
<p>在中序数组中找到头节点，确定左子树元素后，如何确定先序数组左子树元素的区间？</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112173151771.png" alt="确定先序数组左子树元素的区间1"></p>
<p>即L1+1向右走find-1 - L2长度</p>
<p>举个例子就可以发现：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112173230553.png" alt="确定先序数组左子树元素的区间"></p>
<p>新区间范围应该是L1 ~ L1+find-L2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树节点结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">		TreeNode left;</span><br><span class="line">		TreeNode right;</span><br><span class="line"></span><br><span class="line">		TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">			<span class="keyword">this</span>.val = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree1</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//先序数组为空、中序数组为空、中序数组先序数组长度不相等</span></span><br><span class="line">   <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length != in.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一棵树，先序结果是pre[L1...R1]，中序结果是in[L2...R2]</span></span><br><span class="line"><span class="comment">// 请建出整棵树返回头节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span>[] in, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//左数为空或者右树为空</span></span><br><span class="line">   <span class="keyword">if</span> (L1 &gt; R1) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//只有一个节点，返回这个节点即可</span></span><br><span class="line">   TreeNode head = <span class="keyword">new</span> TreeNode(pre[L1]);</span><br><span class="line">   <span class="keyword">if</span> (L1 == R1) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> find = L2;</span><br><span class="line">   <span class="comment">//遍历找到中序数组中头节点对应的位置</span></span><br><span class="line">   <span class="keyword">while</span> (in[find] != pre[L1]) &#123;</span><br><span class="line">      find++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//确定左子树的先序数组、中序数组，右子树的先序数组、中序数组，递归</span></span><br><span class="line">   head.left = f(pre, L1 + <span class="number">1</span>, L1 + find - L2, in, L2, find - <span class="number">1</span>);</span><br><span class="line">   head.right = f(pre, L1 + find - L2 + <span class="number">1</span>, R1, in, find + <span class="number">1</span>, R2);</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以空间换时间，用表记录中序数组每个元素出现的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree2</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length != in.length) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//一张表，记录中序数组中每一个值所在的位置</span></span><br><span class="line">		HashMap&lt;Integer, Integer&gt; valueIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">			valueIndexMap.put(in[i], i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> g(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>, valueIndexMap);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有一棵树，先序结果是pre[L1...R1]，中序结果是in[L2...R2]</span></span><br><span class="line">	<span class="comment">// 请建出整棵树返回头节点</span></span><br><span class="line">	<span class="comment">//空间换时间，时间复杂度O(n)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">g</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span>[] in, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2,</span></span></span><br><span class="line"><span class="params"><span class="function">			HashMap&lt;Integer, Integer&gt; valueIndexMap)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (L1 &gt; R1) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		TreeNode head = <span class="keyword">new</span> TreeNode(pre[L1]);</span><br><span class="line">		<span class="keyword">if</span> (L1 == R1) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//直接从表中获取中序数组中头节点的位置</span></span><br><span class="line">		<span class="keyword">int</span> find = valueIndexMap.get(pre[L1]);</span><br><span class="line">		head.left = g(pre, L1 + <span class="number">1</span>, L1 + find - L2, in, L2, find - <span class="number">1</span>, valueIndexMap);</span><br><span class="line">		head.right = g(pre, L1 + find - L2 + <span class="number">1</span>, R1, in, find + <span class="number">1</span>, R2, valueIndexMap);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树 比较器 优先队列</tag>
      </tags>
  </entry>
</search>
