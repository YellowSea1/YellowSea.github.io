<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>反射</title>
    <url>/2021/01/18/JavaSE/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h2 id="通过案例体会反射的好处"><a href="#通过案例体会反射的好处" class="headerlink" title="通过案例体会反射的好处"></a>通过案例体会反射的好处</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//接口的制定方：美团外卖</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mtwm</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在线支付功能：</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">payOnline</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不同厂家对接口的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChat</span> <span class="keyword">implements</span> <span class="title">Mtwm</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOnline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体实现微信支付的功能：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我已经点了外卖，正在使用微信支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPay</span> <span class="keyword">implements</span> <span class="title">Mtwm</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOnline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体的支付宝支付：</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我已经点了外卖，我正在使用支付宝进行支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankCard</span> <span class="keyword">implements</span> <span class="title">Mtwm</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payOnline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我已经定了外卖，我正在用招商银行信用卡支付&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个字符串，用来模拟前台的支付方式：</span></span><br><span class="line">        String str = <span class="string">&quot;微信&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;微信&quot;</span>.equals(str))&#123;<span class="comment">//不使用str.equals(&quot;微信&quot;)？避免空指针异常</span></span><br><span class="line">            <span class="comment">//微信支付：</span></span><br><span class="line">            <span class="comment">//new WeChat().payOnline();</span></span><br><span class="line">            pay(<span class="keyword">new</span> WeChat());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;支付宝&quot;</span>.equals(str))&#123;</span><br><span class="line">            <span class="comment">//支付宝支付：</span></span><br><span class="line">            <span class="comment">//new AliPay().payOnline();</span></span><br><span class="line">            pay(<span class="keyword">new</span> AliPay());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;招商银行&quot;</span>.equals(str))&#123;</span><br><span class="line">            pay(<span class="keyword">new</span> BankCard());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//微信支付</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(WeChat wc)</span></span>&#123;</span><br><span class="line">        wc.payOnline();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//支付宝支付</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(AliPay ap)</span></span>&#123;</span><br><span class="line">        ap.payOnline();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//招商银行支付</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(BankCard bc)</span></span>&#123;</span><br><span class="line">        bc.payOnline();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提高代码拓展性，可以使用面向对象的特性  <strong>多态</strong> 进行实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个字符串，用来模拟前台的支付方式：</span></span><br><span class="line">        String str = <span class="string">&quot;微信&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;微信&quot;</span>.equals(str))&#123;<span class="comment">//str.equals(&quot;微信&quot;)---？避免空指针异常</span></span><br><span class="line">            <span class="comment">//微信支付：</span></span><br><span class="line">            pay(<span class="keyword">new</span> WeChat());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;支付宝&quot;</span>.equals(str))&#123;</span><br><span class="line">            <span class="comment">//支付宝支付：</span></span><br><span class="line">            pay(<span class="keyword">new</span> AliPay());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;招商银行&quot;</span>.equals(str))&#123;</span><br><span class="line">            pay(<span class="keyword">new</span> BankCard());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法形参是接口，具体传入的是接口的实现类的对象---》多态的一种形式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(Mtwm m)</span></span>&#123;</span><br><span class="line">        m.payOnline();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多态可以提高代码的扩展性，但是并没有使扩展性达到最好；如案例所示多态还需要手动添加或删除一些判断分支。</p>
<p>利用反射机制可以最好地发挥代码的拓展性，利用反射实现上述功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个字符串，用来模拟前台的支付方式：</span></span><br><span class="line">        String str = <span class="string">&quot;com.zhaoss.test01.AliPay&quot;</span>;  <span class="comment">//字符串：实际上：就是微信类的全限定路径</span></span><br><span class="line">        <span class="comment">//下面的代码就是利用反射：</span></span><br><span class="line">        Class  cls = Class.forName(str);<span class="comment">//cls --&gt; Class类具体的对象--&gt; AliPay字节码信息</span></span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        Method method = cls.getMethod(<span class="string">&quot;payOnline&quot;</span>);</span><br><span class="line">        method.invoke(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p><strong>JAVA反射机制</strong>是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。</p>
<p>在编译后产生字节码文件的时候，类加载器子系统通过二进制字节流，负责从文件系统加载class文件。<br>在执行程序（java.exe）时候，将字节码文件读入JVM中，这个过程叫做<strong>类的加载</strong>。然后在内存中对应创建一个java.lang.Class对象,这个对象会被放入字节码信息中**,这个Class对象,就对应加载那个字节码信息**,这个对象将被作为程序访问方法区中的<strong>这个类的各种数据的外部接口</strong>。</p>
<p>我们可以通过这个对象看到类的结构，这个对象就好像是一面镜子，透过镜子看到类的各种信息，我们形象的称之为<strong>反射</strong>。这种“看透”class的能力（the ability of the program to examine itself）被称为introspection（内省、内观、反省）。Reflection和introspection是常被并提的两个术语。</p>
<p>说明：在运行期间，如果我们要产生某个类的对象，Java虚拟机(JVM)会检查该类型的Class对象是否已被加载。如果没有被加载，JVM会根据类的名称找到.class文件并加载它。一旦某个类型的Class对象已被加载到内存，就可以用它来产生该类型的所有对象。某个类型的Class只会被加载一次。</p>
<blockquote>
<p><strong>动态语膏vs静态语言</strong><br>1、动态语言<br>是一类在运行时可以改变其结构的语言:例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。<br>主要动态语言: Object-C、 C#、JavaScript、 PHP、 Python、 Erlang 。<br>2、静态语言<br>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</p>
</blockquote>
<p>所以Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。Java的动态性让编程的时候更加灵活! </p>
<h3 id="Class对象的加载过程"><a href="#Class对象的加载过程" class="headerlink" title="Class对象的加载过程"></a><strong>Class对象的加载过程</strong></h3><p><img src="https://gitee.com/hhn060206/img/raw/master/img/20170513133210763" alt="img"></p>
<h3 id="Class类的api详解"><a href="#Class类的api详解" class="headerlink" title="Class类的api详解"></a>Class类的api详解</h3><p><img src="https://gitee.com/hhn060206/img/raw/master/img/20170513135521667" alt="img"></p>
<h2 id="Class类的理解"><a href="#Class类的理解" class="headerlink" title="Class类的理解"></a>Class类的理解</h2><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220121151302388.png" alt="image-20220121151302388"></p>
<h2 id="获取字节码信息-Class对象-的四种形式"><a href="#获取字节码信息-Class对象-的四种形式" class="headerlink" title="获取字节码信息(Class对象)的四种形式"></a>获取字节码信息(Class对象)的四种形式</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//案例：以Person的字节码信息为案例</span></span><br><span class="line">        <span class="comment">//方式1：通过getClass()方法获取</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Class c1 = p.getClass();</span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        <span class="comment">//方式2：通过内置class属性：</span></span><br><span class="line">        Class c2 = Person.class;</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c1==c2);</span><br><span class="line">        <span class="comment">//注意：方式1和方式2  不常用</span></span><br><span class="line">        <span class="comment">//方式3：用的最多：调用Class类提供的静态方法forName</span></span><br><span class="line">        Class c3 = Class.forName(<span class="string">&quot;com.zhaoss.test02.Person&quot;</span>);</span><br><span class="line">        <span class="comment">//方式4：利用类的加载器(了解技能点)</span></span><br><span class="line">        ClassLoader loader = Test.class.getClassLoader();</span><br><span class="line">        Class c4 = loader.loadClass(<span class="string">&quot;com.zhaoss.test02.Person&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意：在运行期间，一个类，只有一个Class对象产生。</strong></p>
<p>三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p>
<h2 id="可以作为Class类实例的种类"><a href="#可以作为Class类实例的种类" class="headerlink" title="可以作为Class类实例的种类"></a>可以作为Class类实例的种类</h2><p>Class类的具体的实例：<br>（1）类：外部类，内部类<br>（2）接口<br>（3）注解<br><strong>（4）数组：同一个维度，同一个元素类型,得到的字节码就是同一个</strong><br>（5）基本数据类型<br>（6）void</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Class类的具体的实例：</span></span><br><span class="line"><span class="comment">        （1）类：外部类，内部类</span></span><br><span class="line"><span class="comment">        （2）接口</span></span><br><span class="line"><span class="comment">        （3）注解</span></span><br><span class="line"><span class="comment">        （4）数组</span></span><br><span class="line"><span class="comment">        （5）基本数据类型</span></span><br><span class="line"><span class="comment">        （6）void</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class c1 = Person.class;</span><br><span class="line">        Class c2 = Comparable.class;</span><br><span class="line">        Class c3 = Override.class;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        Class c4 = arr1.getClass();</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        Class c5 = arr2.getClass();</span><br><span class="line">        System.out.println(c4==c5);<span class="comment">//结果：true .同一个维度，同一个元素类型,得到的字节码就是同一个</span></span><br><span class="line">        </span><br><span class="line">        Class c6 = <span class="keyword">int</span>.class;</span><br><span class="line">        Class c7 = <span class="keyword">void</span>.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h2><h3 id="获取构造器和创建对象"><a href="#获取构造器和创建对象" class="headerlink" title="获取构造器和创建对象"></a>获取构造器和创建对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码信息：</span></span><br><span class="line">        Class cls = Student.class;</span><br><span class="line">        <span class="comment">//通过字节码信息可以获取构造器：</span></span><br><span class="line">        <span class="comment">//getConstructors只能获取当前运行时类的被public修饰的构造器</span></span><br><span class="line">        Constructor[] c1 = cls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor c:c1)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取运行时类的全部修饰符的构造器</span></span><br><span class="line">        Constructor[] c2 = cls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor c:c2)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定的构造器：</span></span><br><span class="line">        <span class="comment">//得到空构造器</span></span><br><span class="line">        Constructor con1 = cls.getConstructor();</span><br><span class="line">        System.out.println(con1);</span><br><span class="line">        <span class="comment">//得到两个参数的有参构造器：</span></span><br><span class="line">        Constructor con2 = cls.getConstructor(<span class="keyword">double</span>.class, <span class="keyword">double</span>.class);</span><br><span class="line">        System.out.println(con2);</span><br><span class="line">        <span class="comment">//得到一个参数的有参构造器：并且是private修饰的</span></span><br><span class="line">        Constructor con3 = cls.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(con3);</span><br><span class="line">        <span class="comment">//有了构造器以后就可以创建对象：</span></span><br><span class="line">        Object o1 = con1.newInstance();</span><br><span class="line">        System.out.println(o1);</span><br><span class="line">        Object o2 = con2.newInstance(<span class="number">180.5</span>, <span class="number">170.6</span>);</span><br><span class="line">        System.out.println(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取属性和对属性进行复制"><a href="#获取属性和对属性进行复制" class="headerlink" title="获取属性和对属性进行复制"></a>获取属性和对属性进行复制</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        <span class="comment">//获取运行时类的字节码信息：</span></span><br><span class="line">        Class cls = Student.class;</span><br><span class="line">        <span class="comment">//获取属性：</span></span><br><span class="line">        <span class="comment">//getFields：获取运行时类和父类中被public修饰的属性</span></span><br><span class="line">        Field[] fields = cls.getFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f:fields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredFields：获取运行时类中的所有属性</span></span><br><span class="line">        Field[] declaredFields = cls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field f:declaredFields)&#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定的属性：</span></span><br><span class="line">        <span class="comment">//只能获取被public修饰的属性</span></span><br><span class="line">        Field score = cls.getField(<span class="string">&quot;score&quot;</span>);</span><br><span class="line">        System.out.println(score);</span><br><span class="line">        <span class="comment">//可以获取任意属性</span></span><br><span class="line">        Field sno = cls.getDeclaredField(<span class="string">&quot;sno&quot;</span>);</span><br><span class="line">        System.out.println(sno);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//属性的具体结构：</span></span><br><span class="line">        <span class="comment">//获取修饰符</span></span><br><span class="line">        <span class="comment">/*int modifiers = sno.getModifiers();</span></span><br><span class="line"><span class="comment">        System.out.println(modifiers);</span></span><br><span class="line"><span class="comment">        System.out.println(Modifier.toString(modifiers));*/</span></span><br><span class="line">        System.out.println(Modifier.toString(sno.getModifiers()));</span><br><span class="line">        <span class="comment">//获取属性的数据类型：</span></span><br><span class="line">        Class clazz = sno.getType();</span><br><span class="line">        System.out.println(clazz.getName());</span><br><span class="line">        <span class="comment">//获取属性的名字：</span></span><br><span class="line">        String name = sno.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//给属性赋值：(给属性设置值，必须要有对象)</span></span><br><span class="line">        Field sco = cls.getField(<span class="string">&quot;score&quot;</span>);</span><br><span class="line">        Object obj = cls.newInstance();</span><br><span class="line">        sco.set(obj,<span class="number">98</span>);<span class="comment">//给obj这个对象的score属性设置具体的值，这个值为98</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        <span class="comment">//给私有属性赋值：需要解除私有限定</span></span><br><span class="line">        f = stuClass.getDeclaredField(<span class="string">&quot;phoneNum&quot;</span>);  </span><br><span class="line">        System.out.println(f);  </span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射，解除私有限定  </span></span><br><span class="line">        f.set(obj, <span class="string">&quot;18888889999&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;验证电话：&quot;</span> + stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>调用字段时：需要传递两个参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = stuClass.getConstructor().newInstance();<span class="comment">//产生Student对象--》Student stu = new Student();</span></span><br><span class="line"><span class="comment">//为字段设置值</span></span><br><span class="line">f.set(obj, <span class="string">&quot;刘德华&quot;</span>);<span class="comment">//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一个参数：要传入设置的对象，第二个参数：要传入实参;如果是私有变量需要接触私有限定。</p>
<h3 id="获取方法和调用方法"><a href="#获取方法和调用方法" class="headerlink" title="获取方法和调用方法"></a>获取方法和调用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码信息：</span></span><br><span class="line">        Class cls = Student.class;</span><br><span class="line">        <span class="comment">//获取方法：</span></span><br><span class="line">        <span class="comment">//getMethods:获取运行时类的方法还有所有父类中的方法（被public修饰）</span></span><br><span class="line">        Method[] methods = cls.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m:methods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取运行时类中的所有方法：</span></span><br><span class="line">        Method[] declaredMethods = cls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m:declaredMethods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取指定的方法：</span></span><br><span class="line">        Method showInfo1 = cls.getMethod(<span class="string">&quot;showInfo&quot;</span>);</span><br><span class="line">        System.out.println(showInfo1);</span><br><span class="line">        Method showInfo2 = cls.getMethod(<span class="string">&quot;showInfo&quot;</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(showInfo2);</span><br><span class="line">        Method work = cls.getDeclaredMethod(<span class="string">&quot;work&quot;</span>,<span class="keyword">int</span>.class);</span><br><span class="line">        System.out.println(work);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取方法的具体结构：</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        @注解</span></span><br><span class="line"><span class="comment">        修饰符 返回值类型  方法名(参数列表) throws XXXXX&#123;&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//名字：</span></span><br><span class="line">        System.out.println(work.getName());</span><br><span class="line">        <span class="comment">//修饰符：</span></span><br><span class="line">        <span class="keyword">int</span> modifiers = work.getModifiers();</span><br><span class="line">        System.out.println(Modifier.toString(modifiers));</span><br><span class="line">        <span class="comment">//返回值：</span></span><br><span class="line">        System.out.println(work.getReturnType());</span><br><span class="line">        <span class="comment">//参数列表：</span></span><br><span class="line">        Class[] parameterTypes = work.getParameterTypes();</span><br><span class="line">        <span class="keyword">for</span>(Class c:parameterTypes)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取注解：只有在运行时可以获取的注解才可以被反射获取</span></span><br><span class="line">        Method myMethod = cls.getMethod(<span class="string">&quot;myMethod&quot;</span>);</span><br><span class="line">        Annotation[] annotations = myMethod.getAnnotations();        </span><br><span class="line">        <span class="keyword">for</span>(Annotation a:annotations)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取异常：</span></span><br><span class="line">        Class[] exceptionTypes = myMethod.getExceptionTypes();</span><br><span class="line">        <span class="keyword">for</span>(Class c:exceptionTypes)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用方法：</span></span><br><span class="line">        Object o = cls.newInstance();</span><br><span class="line">        myMethod.invoke(o);<span class="comment">//调用o对象的mymethod方法</span></span><br><span class="line">        System.out.println(showInfo2.invoke(o,<span class="number">12</span>,<span class="number">45</span>));</span><br><span class="line">       	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m = stuClass.getDeclaredMethod(<span class="string">&quot;show4&quot;</span>, <span class="keyword">int</span>.class);<span class="comment">//调用制定方法（所有包括私有的），需要传入两个参数，第一个是调用的方法名称，第二个是方法的形参类型，切记是类型。</span></span><br><span class="line">System.out.println(m);</span><br><span class="line">m.setAccessible(<span class="keyword">true</span>);<span class="comment">//解除私有限定</span></span><br><span class="line">Object result = m.invoke(obj, <span class="number">20</span>);<span class="comment">//需要两个参数，一个是要调用的对象（获取有反射），一个是实参</span></span><br><span class="line">System.out.println(<span class="string">&quot;返回值：&quot;</span> + result);<span class="comment">//</span></span><br></pre></td></tr></table></figure>



<h3 id="获取类的接口，所在包，注解"><a href="#获取类的接口，所在包，注解" class="headerlink" title="获取类的接口，所在包，注解"></a>获取类的接口，所在包，注解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取字节码信息：</span></span><br><span class="line">        Class cls = Student.class;</span><br><span class="line">        <span class="comment">//获取运行时类的接口：</span></span><br><span class="line">        Class[] interfaces = cls.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c:interfaces)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到父类的接口：</span></span><br><span class="line">        <span class="comment">//先得到父类的字节码信息：</span></span><br><span class="line">        Class superclass = cls.getSuperclass();</span><br><span class="line">        <span class="comment">//得到接口：</span></span><br><span class="line">        Class[] interfaces1 = superclass.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c:interfaces1)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取运行时类所在的包：</span></span><br><span class="line">        Package aPackage = cls.getPackage();</span><br><span class="line">        System.out.println(aPackage);</span><br><span class="line">        System.out.println(aPackage.getName());</span><br><span class="line">        <span class="comment">//获取运行类的注解：</span></span><br><span class="line">        Annotation[] annotations = cls.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation a:annotations)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>它赋予了我们在运行时分析类以及执行类中方法的能力。</p>
<p>通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<h3 id="反射机制的优缺点？"><a href="#反射机制的优缺点？" class="headerlink" title="反射机制的优缺点？"></a>反射机制的优缺点？</h3><p>优点：使用了java语言的动态性， 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</p>
<p>缺点：让我们在运行时有了分析操作类的能力，这同样也增加了<strong>安全问题</strong>。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，<strong>反射的性能也要稍差点</strong>，不过，对于框架来说实际是影响不大的。 </p>
<h3 id="反射的应用场景？"><a href="#反射的应用场景？" class="headerlink" title="反射的应用场景？"></a>反射的应用场景？</h3><p>业务代码中很少接触到直接使用反射机制的场景。</p>
<p>但像Spring/SpringBoot、Mybatis等等<strong>框架</strong>都大量使用了反射机制。</p>
<p><strong>这些框架大量使用了动态代理，动态代理的实现也依赖反射。</strong>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DebugInvocationHandler</span><span class="params">(Object targrt)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target=target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy,Method,Object[] args)</span><span class="keyword">throws</span> InvocationTargetException, IllegalAccessException</span>&#123;</span><br><span class="line"> 		System.out.println(<span class="string">&quot;before method &quot;</span> + method.getName());</span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;after method &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;   </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/2021/01/18/JavaSE/%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="【1】什么是泛型（Generic）："><a href="#【1】什么是泛型（Generic）：" class="headerlink" title="【1】什么是泛型（Generic）："></a>【1】什么是泛型（Generic）：</h3><p>泛型就相当于标签<br>形式：&lt;&gt;  </p>
<p>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为<strong>Object</strong>，JDK1.5之 后使用泛型来解决。</p>
<p>因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。</p>
<p>Collection<E>, List<E>， ArrayList<E> 这个<E>就是类型参数，即泛型。</p>
<blockquote>
<p>提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型</p>
<p>泛型的本质是参数化类型,也就是说所操作的数据类型被指定为一个参数</p>
<p><strong>类型擦除：Java在运行期间，所有的泛型信息都会被擦除</strong></p>
</blockquote>
<h3 id="【2】没有泛型的时候使用集合："><a href="#【2】没有泛型的时候使用集合：" class="headerlink" title="【2】没有泛型的时候使用集合："></a>【2】没有泛型的时候使用集合：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.msb.test01;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : msb-zhaoss</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这是main方法，程序的入口</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//创建一个ArrayList集合，向这个集合中存入学生的成绩：</span></span><br><span class="line">       ArrayList al = <span class="keyword">new</span> ArrayList();</span><br><span class="line">       al.add(<span class="number">98</span>);</span><br><span class="line">       al.add(<span class="number">18</span>);</span><br><span class="line">       al.add(<span class="number">39</span>);</span><br><span class="line">       al.add(<span class="number">60</span>);</span><br><span class="line">       al.add(<span class="number">83</span>);</span><br><span class="line">       al.add(<span class="string">&quot;丽丽&quot;</span>);</span><br><span class="line">       <span class="comment">//对集合遍历查看：</span></span><br><span class="line">       <span class="keyword">for</span>(Object obj:al)&#123;</span><br><span class="line">           System.out.println(obj);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>如果不使用泛型的话，有缺点：<br>一般我们在使用的时候基本上往集合中存入的都是相同类型的数据–》便于管理，所以现在什么引用数据类型都可以存入集合，不方便！</p>
<h3 id="【3】JDK1-5以后开始使用泛型，集合中使用泛型："><a href="#【3】JDK1-5以后开始使用泛型，集合中使用泛型：" class="headerlink" title="【3】JDK1.5以后开始使用泛型，集合中使用泛型："></a>【3】JDK1.5以后开始使用泛型，集合中使用泛型：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.msb.test01;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : msb-zhaoss</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这是main方法，程序的入口</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//创建一个ArrayList集合，向这个集合中存入学生的成绩：</span></span><br><span class="line">       <span class="comment">//加入泛型的优点：在编译时期就会对类型进行检查，不是泛型对应的类型就不可以添加入这个集合。</span></span><br><span class="line">       ArrayList&lt;Integer&gt; al = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">       al.add(<span class="number">98</span>);</span><br><span class="line">       al.add(<span class="number">18</span>);</span><br><span class="line">       al.add(<span class="number">39</span>);</span><br><span class="line">       al.add(<span class="number">60</span>);</span><br><span class="line">       al.add(<span class="number">83</span>);</span><br><span class="line">       <span class="comment">/*al.add(&quot;丽丽&quot;);</span></span><br><span class="line"><span class="comment">       al.add(9.8);*/</span></span><br><span class="line">       <span class="comment">//对集合遍历查看：</span></span><br><span class="line">       <span class="comment">/*for(Object obj:al)&#123;</span></span><br><span class="line"><span class="comment">           System.out.println(obj);</span></span><br><span class="line"><span class="comment">       &#125;*/</span></span><br><span class="line">       <span class="keyword">for</span>(Integer i:al)&#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="【4】泛型总结："><a href="#【4】泛型总结：" class="headerlink" title="【4】泛型总结："></a>【4】泛型总结：</h3><p>（1）JDK1.5以后<br>（2）泛型实际就是 一个&lt;&gt;引起来的 参数类型，这个参数类型  具体在使用的时候才会确定具体的类型（3）使用了泛型以后，可以确定集合中存放数据的类型，在<strong>编译时期</strong>就可以检查出来。<br>（4）使用泛型你可能觉得麻烦，实际使用了泛型才会简单，后续的遍历等操作简单。<br>（5）泛型的类型：都是<strong>引用数据类型，不能是基本数据类型</strong>。<br>（6）<code>ArrayList&lt;Integer&gt; al = new ArrayList&lt;Integer&gt;();</code>在JDK1.7以后可以写为：<br><code>ArrayList&lt;Integer&gt; al = new ArrayList&lt;&gt;(); </code>    —   &lt;&gt;  —钻石运算符</p>
<h2 id="泛型类，泛型接口"><a href="#泛型类，泛型接口" class="headerlink" title="泛型类，泛型接口"></a>泛型类，泛型接口</h2><h3 id="【1】泛型类的定义和实例化："><a href="#【1】泛型类的定义和实例化：" class="headerlink" title="【1】泛型类的定义和实例化："></a>【1】泛型类的定义和实例化：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.msb.test02;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : msb-zhaoss</span></span><br><span class="line"><span class="comment"> * GenericTes就是一个普通的类</span></span><br><span class="line"><span class="comment"> * GenericTest&lt;E&gt; 就是一个泛型类</span></span><br><span class="line"><span class="comment"> * &lt;&gt;里面就是一个参数类型，但是这个类型是什么呢？这个类型现在是不确定的，相当于一个占位</span></span><br><span class="line"><span class="comment"> * 但是现在确定的是这个类型一定是一个引用数据类型，而不是基本数据类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> age;</span><br><span class="line">   String name;</span><br><span class="line">   E sex;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(E n)</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(E[] m)</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">   <span class="comment">//这是main方法，程序的入口</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//GenericTest进行实例化：</span></span><br><span class="line">       <span class="comment">//(1)实例化的时候不指定泛型：如果实例化的时候不明确的指定类的泛型，那么认为此泛型为Object类型</span></span><br><span class="line">       GenericTest gt1 = <span class="keyword">new</span> GenericTest();</span><br><span class="line">       gt1.a(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">       gt1.a(<span class="number">17</span>);</span><br><span class="line">       gt1.a(<span class="number">9.8</span>);</span><br><span class="line">       gt1.b(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;);</span><br><span class="line">       <span class="comment">//（2）实例化的时候指定泛型：---》推荐方式</span></span><br><span class="line">       GenericTest&lt;String&gt; gt2 = <span class="keyword">new</span> GenericTest&lt;&gt;();</span><br><span class="line">       gt2.sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">       gt2.a(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">       gt2.b(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;);</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="【2】继承情况："><a href="#【2】继承情况：" class="headerlink" title="【2】继承情况："></a>【2】继承情况：</h3><p>（1）父类指定泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubGenericTest</span> <span class="keyword">extends</span> <span class="title">GenericTest</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="comment">//这是main方法，程序的入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指定父类泛型，那么子类就不需要再指定泛型了，可以直接使用</span></span><br><span class="line">        SubGenericTest sgt = <span class="keyword">new</span> SubGenericTest();</span><br><span class="line">        sgt.a(<span class="number">19</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）父类不指定泛型：<br>如果父类不指定泛型，那么子类也会变成一个泛型类，那这个E的类型可以在创建子类对象的时候确定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubGenericTest2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">GenericTest</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2</span></span>&#123;</span><br><span class="line">    <span class="comment">//这是main方法，程序的入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubGenericTest2&lt;String&gt; s = <span class="keyword">new</span>  SubGenericTest2&lt;&gt;();</span><br><span class="line">        s.a(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        s.sex = <span class="string">&quot;女&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【3】应用场合：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220118145847874.png" alt="image-20220118145847874"></p>
<p>【4】细节：<br>（1）泛型类可以定义多个参数类型</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220118145859367.png" alt="image-20220118145859367"></p>
<p>（2）泛型类的构造器的写法：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220118145907529.png" alt="image-20220118145907529"></p>
<p>（3）不同的泛型的引用类型不可以相互赋值：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220118145914649.png" alt="image-20220118145914649"></p>
<p>（4）泛型如果不指定，那么就会被擦除，泛型对应的类型为Object类型：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220118150028999.png" alt="image-20220118150028999"></p>
<p>（5）反省类中的静态方法不能使用类的泛型：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220118150108957.png" alt="image-20220118150108957"></p>
<p>静态方法在类加载时就在内存中存在，也就是没有经过实例化就存在了，也就是还没有指定类的时候就存在了</p>
<p>（6）不能直接使用E[]的创建：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220118150310066.png" alt="image-20220118150310066"></p>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>1.什么是泛型方法：</p>
<p>不是带泛型的方法就是泛型方法</p>
<p>泛型方法有要求：这个方法的泛型的参数类型要和当前的类的泛型无关</p>
<p>换个角度：</p>
<p><strong>泛型方法对应的那个泛型参数类型 和  当前所在的这个类 是否是泛型类，泛型是啥无关</strong></p>
<p><strong>2.泛型方法定义的时候，前面要加上<T></strong></p>
<p>原因：如果不加的话，会把T当做一种数据类型，然而代码中没有T类型那么就会报错</p>
<p>3.T的类型是在调用方法的时候确定的</p>
<p><strong>4.泛型方法可否是静态方法？可以是静态方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.msb.test04;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : msb-zhaoss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGeneric</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//不是泛型方法 （不能是静态方法）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;  <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="comment">//这是main方法，程序的入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestGeneric&lt;String&gt; tg = <span class="keyword">new</span> TestGeneric&lt;&gt;();</span><br><span class="line">        tg.a(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        tg.b(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        tg.b(<span class="number">19</span>);</span><br><span class="line">        tg.b(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="泛型参数存在继承关系的情况"><a href="#泛型参数存在继承关系的情况" class="headerlink" title="泛型参数存在继承关系的情况"></a>泛型参数存在继承关系的情况</h2><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220118150711157.png" alt="image-20220118150711157"></p>
<p>实际上只在编译时进行类型的替换，在运行时list1和list2底层都是Object类型</p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><h3 id="【1】在没有通配符的时候："><a href="#【1】在没有通配符的时候：" class="headerlink" title="【1】在没有通配符的时候："></a>【1】在没有通配符的时候：</h3><p>下面的a方法，相当于方法的重复定义，报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*public void a(List&lt;Object&gt; list)&#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public void a(List&lt;String&gt; list)&#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    public void a(List&lt;Integer&gt; list)&#123;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="【2】引入通配符："><a href="#【2】引入通配符：" class="headerlink" title="【2】引入通配符："></a>【2】引入通配符：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是main方法，程序的入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;?&gt; list = <span class="keyword">null</span>;</span><br><span class="line">        list = list1;</span><br><span class="line">        list = list2;</span><br><span class="line">        list = list3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现： A 和 B是子类父类的关系，G<A>和G<B>不存在子类父类关系，是并列的<br>加入通配符？后，<strong>G&lt;?&gt;就变成了 G<A>和G<B>的父类</strong></p>
<h3 id="【3】使用通配符："><a href="#【3】使用通配符：" class="headerlink" title="【3】使用通配符："></a>【3】使用通配符：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.msb.test06;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : msb-zhaoss</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">   <span class="comment">/*public void a(List&lt;Object&gt; list)&#123;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   public void a(List&lt;String&gt; list)&#123;</span></span><br><span class="line"><span class="comment">   &#125;</span></span><br><span class="line"><span class="comment">   public void a(List&lt;Integer&gt; list)&#123;</span></span><br><span class="line"><span class="comment">   &#125;*/</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">       <span class="comment">//内部遍历的时候用Object即可，不用？</span></span><br><span class="line">       <span class="keyword">for</span>(Object a:list)&#123;</span><br><span class="line">           System.out.println(a);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">T</span></span>&#123;</span><br><span class="line">   <span class="comment">//这是main方法，程序的入口</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Test t = <span class="keyword">new</span> Test();</span><br><span class="line">       t.a(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">       t.a(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">       t.a(<span class="keyword">new</span> ArrayList&lt;Object&gt;());</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>【4】查看API中应用位置：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220118151016298.png" alt="image-20220118151016298"></p>
<h2 id="使用通配符后的细节"><a href="#使用通配符后的细节" class="headerlink" title="使用通配符后的细节"></a>使用通配符后的细节</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.遍历：使用Object类型遍历元素</span></span><br><span class="line">        <span class="keyword">for</span>(Object a:list)&#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.数据的写入操作 ：</span></span><br><span class="line">        <span class="comment">//list.add(&quot;abc&quot;);--&gt;出错，不能随意的添加数据</span></span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//3.数据的读取操作：</span></span><br><span class="line">        Object s = list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span></span>&#123;</span><br><span class="line">    <span class="comment">//这是main方法，程序的入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test t = <span class="keyword">new</span> Test();</span><br><span class="line">        t.a(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        t.a(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        t.a(<span class="keyword">new</span> ArrayList&lt;Object&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型受限"><a href="#泛型受限" class="headerlink" title="泛型受限"></a>泛型受限</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.msb.test07;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : msb-zhaoss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是main方法，程序的入口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//a,b,c三个集合是并列的关系：</span></span><br><span class="line">        List&lt;Object&gt; a = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Person&gt; b = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Student&gt; c = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">/*开始使用泛型受限：泛型的上限</span></span><br><span class="line"><span class="comment">        List&lt;? extends Person&gt;:</span></span><br><span class="line"><span class="comment">        就相当于：</span></span><br><span class="line"><span class="comment">        List&lt;? extends Person&gt;是List&lt;Person&gt;的子类，是List&lt;Person的子类&gt;的子类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;? extends Person&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/*list1 = a;</span></span><br><span class="line"><span class="comment">        list1 = b;</span></span><br><span class="line"><span class="comment">        list1 = c;*/</span></span><br><span class="line">        <span class="comment">/*开始使用泛型受限：泛型的下限</span></span><br><span class="line"><span class="comment">        List&lt;? super Person&gt;</span></span><br><span class="line"><span class="comment">        就相当于：</span></span><br><span class="line"><span class="comment">        List&lt;? super Person&gt;是List&lt;Person&gt;的父类，是List&lt;Person的父类&gt;的父类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;? <span class="keyword">super</span> Person&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line">        list2 = a;</span><br><span class="line">        list2 = b;</span><br><span class="line">        list3 = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法|时间复杂度|动态数组|哈希表</title>
    <url>/2021/01/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E3%80%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%81%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>几种应用场景：</p>
<ul>
<li><strong>有序数组</strong>中找到num</li>
<li><strong>有序数组</strong>中找到&gt;=num最左的位置</li>
<li><strong>有序数组</strong>中找到&lt;=num最右的位置</li>
<li>局部最小值问题</li>
</ul>
<h3 id="1-有序数组中找到num"><a href="#1-有序数组中找到num" class="headerlink" title="1.有序数组中找到num"></a>1.有序数组中找到num</h3><h3 id="2-有序数组中找到-gt-num最左的位置"><a href="#2-有序数组中找到-gt-num最左的位置" class="headerlink" title="2.有序数组中找到&gt;=num最左的位置"></a>2.<strong>有序数组</strong>中找到&gt;=num最左的位置</h3><p>array[mid]&lt;num 舍去左边部分，改变左边界L=mid+1</p>
<p>array[mid]&gt;=num 舍去右边部分，改变右边界R=mid-1  //等号在这里，舍去靠右的index  <strong>易错</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mostLeftNoLessNumIndex</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span> || array == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> R = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> midValue=array[mid];</span><br><span class="line">            <span class="keyword">if</span> (midValue &lt; num) &#123;</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//array[mid]&gt;num</span></span><br><span class="line">                R = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-有序数组中找到-lt-num最右的位置"><a href="#3-有序数组中找到-lt-num最右的位置" class="headerlink" title="3.有序数组中找到&lt;=num最右的位置"></a>3.<strong>有序数组</strong>中找到&lt;=num最右的位置</h3><p>array[mid]&lt;=num舍去左边部分，改变左边界L=mid+1 //等号在这里，舍去靠左的index <strong>易错</strong></p>
<p>array[mid]&gt;num 舍去右边部分，改变右边界R=mid-1 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mostRightNoMoreIndex</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span> || array == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (array[mid] &lt;= num) &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//array[mid]&gt;num</span></span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-局部最小值问题"><a href="#4-局部最小值问题" class="headerlink" title="4.局部最小值问题"></a>4.局部最小值问题</h3><p>条件：数组是无序的，且相邻数不相等</p>
<p>分析思路：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/%E6%97%A0%E6%A0%87%E9%A2%98.png" alt="分析思路"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arr 整体无序</span></span><br><span class="line">	<span class="comment">// arr 相邻的数不相等！</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">oneMinIndex</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> N = arr.length;</span><br><span class="line">		<span class="keyword">if</span> (N == <span class="number">1</span>) &#123; <span class="comment">//容易遗漏的边界条件</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (arr[N - <span class="number">1</span>] &lt; arr[N - <span class="number">2</span>]) &#123;</span><br><span class="line">			<span class="keyword">return</span> N - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> R = N - <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// L...R 肯定有局部最小</span></span><br><span class="line">		<span class="keyword">while</span> (L &lt; R - <span class="number">1</span>) &#123;  <span class="comment">// L-R至少有三个数,否则mid-1会溢出</span></span><br><span class="line">			<span class="keyword">int</span> mid = (L + R) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (arr[mid] &lt; arr[mid - <span class="number">1</span>] &amp;&amp; arr[mid] &lt; arr[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="keyword">return</span> mid;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">					R = mid - <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123; <span class="comment">// arr[mid]&lt;arr[mid-1]</span></span><br><span class="line">					L = mid + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[L] &lt; arr[R] ? L : R;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>二分不一定需要有序，在某一个标准下，只要确定某一侧肯定有，就可以二分</p>
</blockquote>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>在算法函数中，数据量很大时最高阶项算法和时间的关系；</p>
<p>要假设最差情况，才是算法的时间复杂度。</p>
<h3 id="常见时间复杂度列表-（略）"><a href="#常见时间复杂度列表-（略）" class="headerlink" title="常见时间复杂度列表 （略）"></a>常见时间复杂度列表 （略）</h3><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>ArrayList</p>
<p>扩容代价：数组扩容n个数(扩容操作：扩容、拷贝，算法函数是等比数列)，时间复杂度为O(n)，均摊到每次扩容，时间复杂度为O(n)/n=1，很小，<strong>可以忽略不计</strong>；<strong>故动态数组的优点是，从时间复杂度来说，和固定数组性能相差不大，还可以动态扩容。</strong></p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220103194317735.png" alt="扩容过程"></p>
<h2 id="哈希表和有序表"><a href="#哈希表和有序表" class="headerlink" title="哈希表和有序表"></a>哈希表和有序表</h2><h3 id="哈希表-HashMap"><a href="#哈希表-HashMap" class="headerlink" title="哈希表   HashMap()"></a>哈希表   HashMap()</h3><ol>
<li><p>增删查改操作时间复杂度都是常数级别，但是时间略长</p>
</li>
<li><p>基本数据类型按值传递，自定义类型按引用传递；即基本数据类型在哈希表中存储的是值本身，自定义的类型在哈希表中存储的是引用；哈希表的基本数据类型在比较时会比较值，自定义类型会比较引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基本数据类型按值传递</span></span><br><span class="line">String test1 = <span class="string">&quot;zuochengyun&quot;</span>;</span><br><span class="line">String test2 = <span class="string">&quot;zuochengyun&quot;</span>;</span><br><span class="line">System.out.println(map.containsKey(test1)); <span class="comment">//输出true</span></span><br><span class="line">System.out.println(map.containsKey(test2)); <span class="comment">//输出false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义的类型按引用传递</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">			value = v;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node node1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">Node node2 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">HashMap&lt;Node, String&gt; map3 = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map3.put(node1, <span class="string">&quot;我进来了！&quot;</span>);</span><br><span class="line">System.out.println(map3.containsKey(node1)); <span class="comment">//输出true</span></span><br><span class="line">System.out.println(map3.containsKey(node2)); <span class="comment">//输出false</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="有序表-TreeMap"><a href="#有序表-TreeMap" class="headerlink" title="有序表  TreeMap()"></a>有序表  TreeMap()</h3><ol>
<li><p>键必须是可比较的(基本数据类型的键都可以比较)</p>
</li>
<li><p>一些常用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeMap&lt;Integer,String&gt; treeMap=<span class="keyword">new</span> treeMap&lt;&gt;();</span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line">treeMap.put(<span class="number">0</span>,<span class="string">&quot;我是0&quot;</span>);</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">treeMap.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line">treeMap.get(<span class="number">0</span>); <span class="comment">//输出：我是0</span></span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">treeMap.put(<span class="number">0</span>,<span class="string">&quot;我是1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取最小的key</span></span><br><span class="line">treeMap.firstKey();</span><br><span class="line"><span class="comment">//获取最大的key</span></span><br><span class="line">treeMap.lastKey();</span><br><span class="line"><span class="comment">//获取&lt;=num最近的key</span></span><br><span class="line">treeMap.floorKey(num);</span><br><span class="line"><span class="comment">//获取&gt;=num最近的key</span></span><br><span class="line">treeMap.cellingKey(num);</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二分法 时间复杂度 动态数组 哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树题目</title>
    <url>/2021/01/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="1-二叉树按层遍历并收集节点"><a href="#1-二叉树按层遍历并收集节点" class="headerlink" title="1.二叉树按层遍历并收集节点"></a>1.二叉树按层遍历并收集节点</h3><p><a href="https://leetcode.com/problems/balanced-binary-tree">https://leetcode.com/problems/balanced-binary-tree</a></p>
<p><strong>如何顺序收集每层节点的list？</strong></p>
<p>(1) 使用队列收集每一层的节点（队列可以用arrayList或LinkedList实现)</p>
<p>(2) 收集队列的size，size为第三步执行的次数</p>
<p>(3) 弹出节点，先加左节点，有右节点再加右节点</p>
<p><strong>如何逆序？</strong></p>
<p>(1) 如果使用arrayList？首尾交换将链表顺序倒转；<strong>速度慢</strong></p>
<p>(2) 如果使用LinkList?不需要交换，直接加入链表即可；<strong>速度快</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">//使用LinkdList储存链表list</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; curAns = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123; <span class="comment">//不可以直接调用queue.size,队列的size是动态变化的</span></span><br><span class="line">                TreeNode curNode = queue.poll();</span><br><span class="line">                curAns.add(curNode.val);</span><br><span class="line">                <span class="keyword">if</span> (curNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(curNode.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.add(curNode.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(<span class="number">0</span>, curAns); <span class="comment">//从index=0的地方加入，如果不指定index直接使用ans.add(curAns),默认从最后一个index加入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于栈结构：</strong></p>
<p>java中的Stack类型速度较慢，最快的是使用数组结构实现栈</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220113113044339.png" alt="image-20220113113044339"></p>
<h3 id="2-判断是否是平衡二叉树"><a href="#2-判断是否是平衡二叉树" class="headerlink" title="2.判断是否是平衡二叉树"></a>2.判断是否是平衡二叉树</h3><p> <a href="https://leetcode.com/problems/balanced-binary-tree">https://leetcode.com/problems/balanced-binary-tree</a></p>
<p>每一棵子树左树高度与右数高度高度差&lt;=1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> process(root).isBalanced;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以某个节点为头的时候，1)整棵树是否平衡 2)高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isBalanced;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> i, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">		isBalanced = i;</span><br><span class="line">		height = h;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Info(<span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Info leftInfo = process(root.left);</span><br><span class="line">	Info rightInfo = process(root.right);</span><br><span class="line">	<span class="keyword">int</span> height = Math.max(leftInfo.height, rightInfo.height) + <span class="number">1</span>; <span class="comment">//树的高度:左右任意一棵树高度+1</span></span><br><span class="line">	<span class="keyword">boolean</span> isBalanced = leftInfo.isBalanced &amp;&amp; rightInfo.isBalanced</span><br><span class="line">			&amp;&amp; Math.abs(leftInfo.height - rightInfo.height) &lt; <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(isBalanced, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-搜索二叉树"><a href="#2-搜索二叉树" class="headerlink" title="2.搜索二叉树"></a>2.搜索二叉树</h3><p>任意一棵子树，左子树节点比头节点小，右子树节点比头节点大</p>
<p><strong>如何判断一棵树是搜索二叉树？</strong></p>
<p>1）中序遍历严格递增</p>
<p>2）递归；左子树是搜索二叉树，且左子树的值小于头节点；右子树是搜索二叉树，右子树节点的值大于头节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">public</span> TreeNode left;</span><br><span class="line">	<span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">	TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">boolean</span> isBST;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> max;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Info</span><span class="params">(<span class="keyword">boolean</span> is, <span class="keyword">int</span> ma, <span class="keyword">int</span> mi)</span> </span>&#123;</span><br><span class="line">		isBST = is;</span><br><span class="line">		max = ma;</span><br><span class="line">		min = mi;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title">process</span><span class="params">(TreeNode x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Info leftInfo = process(x.left);</span><br><span class="line">	Info rightInfo = process(x.right);</span><br><span class="line">	<span class="keyword">int</span> max = x.val;</span><br><span class="line">	<span class="keyword">int</span> min = x.val;</span><br><span class="line">	<span class="keyword">if</span> (leftInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">		max = Math.max(leftInfo.max, max);</span><br><span class="line">		min = Math.min(leftInfo.min, min);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rightInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">		max = Math.max(rightInfo.max, max);</span><br><span class="line">		min = Math.min(rightInfo.min, min);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> isBST = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (leftInfo != <span class="keyword">null</span> &amp;&amp; !leftInfo.isBST) &#123;</span><br><span class="line">		isBST = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rightInfo != <span class="keyword">null</span> &amp;&amp; !rightInfo.isBST) &#123;</span><br><span class="line">		isBST = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 子树是空也是平衡二叉树</span></span><br><span class="line">	<span class="keyword">boolean</span> leftMaxLessX = leftInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (leftInfo.max &lt; x.val);</span><br><span class="line">	<span class="keyword">boolean</span> rightMinMoreX = rightInfo == <span class="keyword">null</span> ? <span class="keyword">true</span> : (rightInfo.min &gt; x.val);</span><br><span class="line">	<span class="keyword">if</span> (!(leftMaxLessX &amp;&amp; rightMinMoreX)) &#123;</span><br><span class="line">		isBST = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Info(isBST, max, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-能否组成路径和"><a href="#4-能否组成路径和" class="headerlink" title="4.能否组成路径和"></a>4.能否组成路径和</h3><p><a href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">		<span class="keyword">public</span> TreeNode left;</span><br><span class="line">		<span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">		TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">			<span class="keyword">this</span>.val = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isSum = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		isSum = <span class="keyword">false</span>;</span><br><span class="line">		process(root, <span class="number">0</span>, sum);</span><br><span class="line">		<span class="keyword">return</span> isSum;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode x, <span class="keyword">int</span> preSum, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x.left == <span class="keyword">null</span> &amp;&amp; x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x.val + preSum == sum) &#123;</span><br><span class="line">				isSum = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// x是非叶节点</span></span><br><span class="line">		preSum += x.val;</span><br><span class="line">		<span class="keyword">if</span> (x.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">			process(x.left, preSum, sum);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">			process(x.right, preSum, sum);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-路径总和"><a href="#5-路径总和" class="headerlink" title="5.路径总和"></a>5.路径总和</h3><p><a href="https://leetcode-cn.com/problems/path-sum-ii/">https://leetcode-cn.com/problems/path-sum-ii/</a></p>
<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; path=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        process(root,path,<span class="number">0</span>,sum,ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(TreeNode x, List&lt;Integer&gt; path, <span class="keyword">int</span> preSum, <span class="keyword">int</span> sum, List&lt;List&lt;Integer&gt;&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x.left == <span class="keyword">null</span> &amp;&amp; x.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (preSum + x.val == sum) &#123;</span><br><span class="line">                path.add(x.val);</span><br><span class="line">                List&lt;Integer&gt; ans1 = copy(path);</span><br><span class="line">                ans.add(ans1);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不是叶子节点</span></span><br><span class="line">        path.add(x.val);</span><br><span class="line">        preSum += x.val;</span><br><span class="line">        <span class="keyword">if</span> (x.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            process(x.left, path, preSum, sum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            process(x.right, path, preSum, sum, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">copy</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">            list1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>位图、位运算实现加减乘除</title>
    <url>/2021/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BD%8D%E5%9B%BE%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/</url>
    <content><![CDATA[<h2 id="位图、位运算实现加减乘除"><a href="#位图、位运算实现加减乘除" class="headerlink" title="位图、位运算实现加减乘除"></a>位图、位运算实现加减乘除</h2><h3 id="1-位图"><a href="#1-位图" class="headerlink" title="1.位图"></a>1.位图</h3><h4 id="1-1位图的功能"><a href="#1-1位图的功能" class="headerlink" title="1.1位图的功能"></a>1.1位图的功能</h4><p><strong>一个集合，知道一组数的上限和下限，可以通过这个集合收集数字表示这个数字存在或者不存在</strong></p>
<h4 id="1-2位图的好处"><a href="#1-2位图的好处" class="headerlink" title="1.2位图的好处"></a>1.2位图的好处</h4><p><strong>极大地压缩空间；</strong></p>
<p>位图与HashSet用来表示一组数：位图表示一个数可以用1bit,hashSet需要4个字节==&gt;4 * 32bit</p>
<h4 id="1-3位图的实现"><a href="#1-3位图的实现" class="headerlink" title="1.3位图的实现"></a>1.3位图的实现</h4><p>(1)位图用什么来存储？</p>
<p>使用一个long类型的数组存储；每个元素可以表示64个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] bits;</span><br></pre></td></tr></table></figure>

<p>（2）构造函数</p>
<p>需要确定一个数需要多少个元素存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 1.(max + 64) &gt;&gt; 6  ==&gt; (max+64) / 64</span></span><br><span class="line"><span class="comment">			 * 	1.1 max+64:0~63都需要占据一个long</span></span><br><span class="line"><span class="comment">			 * 	1.2 整数右移六位，相当于除以2^6=64</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			bits = <span class="keyword">new</span> <span class="keyword">long</span>[(max + <span class="number">64</span>) &gt;&gt; <span class="number">6</span>];</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>（3）位图添加一个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 	1. num &gt;&gt; 6 ==&gt; num/64</span></span><br><span class="line"><span class="comment">			 * 	2. num &amp; 63 ==&gt; num % 64 ;</span></span><br><span class="line"><span class="comment">			 * 		2.1 num % 64 == num,0&lt;num&lt;63,在二进制中，用0~7位表示即可;两者都是把高于第七位的二进制数归零;</span></span><br><span class="line"><span class="comment">			 * 		2.2 &gt;&gt; &lt;&lt; &amp; | ^ 速度远远大于 + - * /</span></span><br><span class="line"><span class="comment">			 * 	3. 右移运算与或运算</span></span><br><span class="line"><span class="comment">			 * 		3.1 右移：bits数组元素num&gt;&gt;6中num应该标注在第几位</span></span><br><span class="line"><span class="comment">			 * 		3.2 或运算：二进制数与初始的bits[num&gt;&gt;6]相加</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			bits[num &gt;&gt; <span class="number">6</span>] |= (<span class="number">1L</span> &lt;&lt; (num &amp; <span class="number">63</span>));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：一定要与bits[num&gt;&gt;6]进行或运算，否则该元素标志的其他元素将被删除</strong></p>
<p>（4）位图删除一个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 即将相应位数的1归零</span></span><br><span class="line"><span class="comment">			 * 1. &amp;运算：除了相应的位数，其他位都是1，相与即可保持其他位不变，相应位为0</span></span><br><span class="line"><span class="comment">			 * 2. 如何找出这个相与的数？1&lt;&lt;相应位数，然后取反~</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			bits[num &gt;&gt; <span class="number">6</span>] &amp;= ~(<span class="number">1L</span> &lt;&lt; (num &amp; <span class="number">63</span>));</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>如何用&amp;运算将相应位置归零?</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220110114559938.png" alt="image-20220110114559938"></p>
<p>如何求出被&amp;的数？ 1&lt;&lt;相应的位数，取反</p>
<p>(5)是否存在某个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 170是否存在？</span></span><br><span class="line"><span class="comment">			 * 1.bits[num &gt;&gt; 6]:找到170所在的元素</span></span><br><span class="line"><span class="comment">			 * 2.1 &lt;&lt; (num &amp; 63):找到170所在的位</span></span><br><span class="line"><span class="comment">			 * 3.相与：00..000100000..（170bits[2]）&amp;bits[2]</span></span><br><span class="line"><span class="comment">			 * 	3.1 170存在：相应位置为1 结果!=0</span></span><br><span class="line"><span class="comment">			 * 	3.2 170不存在：相应位置为1 结果==0</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">return</span> (bits[num &gt;&gt; <span class="number">6</span>] &amp; (<span class="number">1L</span> &lt;&lt; (num &amp; <span class="number">63</span>))) != <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>**1. &gt;&gt;&lt;&lt; &amp; | ^ 速度远远大于 + - * /:**尽量避免使用+、-、*、%，使用，相应操作使用&gt;&gt;、&lt;&lt;、|、&amp;、^代替</p>
<p>​    1.1 num/2^n ==&gt; num&gt;&gt;n  例如num/2^6 ==&gt; num&gt;&gt;6</p>
<p>​    1.2 num%n ==&gt; 1L&lt;&lt;(num&amp;相应的二进制数)</p>
</blockquote>
<h3 id="2-位运算实现加减乘除"><a href="#2-位运算实现加减乘除" class="headerlink" title="2.位运算实现加减乘除"></a>2.位运算实现加减乘除</h3><p>java中加减乘除的底层是位运算，现在自己动手使用位运算编写一个计算器实现加减乘除；虽然说二者都是通过位运算实现，但是java的位运算速度比自己编写的要高一些。</p>
<p>leetcode测试链接：<a href="https://leetcode.com/problems/divide-two-integers">https://leetcode.com/problems/divide-two-integers</a><br>(1)加法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	        <span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * 1.加法 ==&gt; 无进位相加信息+进位信息，直到进位信息为0</span></span><br><span class="line"><span class="comment">			 * 2.^ 异或运算得到无进位相加信息</span></span><br><span class="line"><span class="comment">			 * 3.&amp; 运算之后右移1位：进位信息</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">		<span class="keyword">int</span> sum = a;</span><br><span class="line">		<span class="keyword">while</span> (b != <span class="number">0</span>) &#123; <span class="comment">//直到进位信息为0</span></span><br><span class="line">			sum = a ^ b; <span class="comment">//无进位相加信息 -&gt; sum</span></span><br><span class="line">			b = (a &amp; b) &lt;&lt; <span class="number">1</span>; <span class="comment">//进位信息 -&gt; b -&gt; b&#x27;</span></span><br><span class="line">			a = sum; <span class="comment">//无进位相加信息 a -&gt; a&#x27;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>(2)减法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相减</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// a-b==&gt; a+(-b)</span></span><br><span class="line">	<span class="keyword">return</span> add(a, negNum(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3)乘法</p>
<p><strong>乘法原理：</strong></p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220110160818108.png" alt="image-20220110160818108"></p>
<p>即数b任意一位为1，则a取全部，否则取0，最后将所有数相加</p>
<p>也可以用下面的方式表示：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220110160442494.png" alt="image-20220110160442494"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//乘法</span></span><br><span class="line"><span class="comment">//支持正负a和正负b</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">multi</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((b &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123; <span class="comment">//检查b最末尾一位是否为1</span></span><br><span class="line">			res = add(res, a); <span class="comment">//为1，res添加a;为0，res不添加任何数;  add不和或运算等同，也不和异或运算等同</span></span><br><span class="line">		&#125;</span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>; <span class="comment">//a左移一位，末端补0</span></span><br><span class="line">		b &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">//b不带符号右移一位，左端补0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(4)除法</p>
<p>除法运算需要处理被除数或者除数含有系统最小值的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//除法运算</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 *  此方法无法处理含有系统最小值的情况</span></span><br><span class="line"><span class="comment">		 *  0.除法的原理：a/b=c</span></span><br><span class="line"><span class="comment">		 *  	0.1 b*c=a a=c为1的位*b再全部相加</span></span><br><span class="line"><span class="comment">		 *  	0.2 如何找出c为1的位？b左移n位时为&lt;a的最大值，则c的第n位为1</span></span><br><span class="line"><span class="comment">		 *  1.a,b都需要转换成正数x,y</span></span><br><span class="line"><span class="comment">		 *  2.x右移30、29、28...0位</span></span><br><span class="line"><span class="comment">		 *  	！2.1 为什么最多只需要右移30位不是31位？31是符号位，符号位都是0</span></span><br><span class="line"><span class="comment">		 *  3.x右移i位&gt;=y,即可以与y相减</span></span><br><span class="line"><span class="comment">		 *  	3.1记录位数</span></span><br><span class="line"><span class="comment">		 *  	3.2x减去y左移相应位数，剩下的数继续参与循环</span></span><br><span class="line"><span class="comment">		 *		！3.3 为什么是x右移而不是y左移？当x较大时，y左移有可能改变符号位，而x右移则不会出现这种情况；两者的移动位数是一样的</span></span><br><span class="line"><span class="comment">		 *	4.a、b同号？结果为正:结果为负</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 *  5.除不尽仍然适用，相当于向下取整：x右移到0仍然没有为0，剩下的值为余数，直接舍弃，相当于向下取整</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> x = isNeg(a) ? negNum(a) : a;</span><br><span class="line">		<span class="keyword">int</span> y = isNeg(b) ? negNum(b) : b;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span>; i &gt;= <span class="number">0</span>; i = minus(i, <span class="number">1</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((x &gt;&gt; i) &gt;= y) &#123;</span><br><span class="line">				res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">				x = minus(x, y &lt;&lt; i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> isNeg(a) ^ isNeg(b) ? negNum(res) : res; <span class="comment">//!=可以用^代替</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//系统最小值的绝对值仍然是最小值本身，所以a或b为系统最小值时需要额外讨论</span></span><br><span class="line">		<span class="keyword">if</span> (a == Integer.MIN_VALUE &amp;&amp; b == Integer.MIN_VALUE) &#123; <span class="comment">//a为最小值或b为最小值时</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (b == Integer.MIN_VALUE) &#123; <span class="comment">//a不为最小值，b为最小值时</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == Integer.MIN_VALUE) &#123; <span class="comment">//a为最小值，b不为最小值时</span></span><br><span class="line">			<span class="keyword">if</span> (b == negNum(<span class="number">1</span>)) &#123; <span class="comment">//若b为1，系统最小值没有对应的最大值，leetcode规定 Integer.MIN_VALUE/1=Integer/MAX_value;</span></span><br><span class="line">				<span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">//b不为1</span></span><br><span class="line">				<span class="comment">/**</span></span><br><span class="line"><span class="comment">				 * (a+1)/b=c;</span></span><br><span class="line"><span class="comment">				 * a-c*b=d;</span></span><br><span class="line"><span class="comment">				 * d/b=e;</span></span><br><span class="line"><span class="comment">				 * ans=c+e</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">int</span> c = div(add(a, <span class="number">1</span>), b);</span><br><span class="line">				<span class="keyword">return</span> add(c, div(minus(a, multi(c, b)), b));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> div(a, b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（6）取相反数 判断数是否小于零</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取相反数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">negNum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 取反然后+1</span></span><br><span class="line">		<span class="keyword">return</span> add(~n, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNeg</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n &lt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二分法 时间复杂度 动态数组 哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表及简单题目</title>
    <url>/2021/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="单链表的反转"><a href="#单链表的反转" class="headerlink" title="单链表的反转"></a>单链表的反转</h2><blockquote>
<p><strong>注意</strong></p>
<p>Jvm的可达性：Jvm会释放掉不可达的内存。–&gt; 链表反转之后需要返回头部，记录头部使链表可达。</p>
</blockquote>
<h3 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h3><h4 id="1-给定一个单链表的头head，完成联表的逆序调整"><a href="#1-给定一个单链表的头head，完成联表的逆序调整" class="headerlink" title="1.给定一个单链表的头head，完成联表的逆序调整"></a>1.给定一个单链表的头head，完成联表的逆序调整</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = head.next; <span class="comment">//next标记当前节点后的链表，防止后续链表丢失</span></span><br><span class="line">            head.next = pre; <span class="comment">//反转指针</span></span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;<span class="comment">//移动pre head</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-给定一个双链表的头head，完成链表的逆序调整"><a href="#2-给定一个双链表的头head，完成链表的逆序调整" class="headerlink" title="2.给定一个双链表的头head，完成链表的逆序调整"></a>2.给定一个双链表的头head，完成链表的逆序调整</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleNode <span class="title">reverseDoubleList</span><span class="params">(DoubleNode head)</span> </span>&#123;</span><br><span class="line">     DoubleNode pre = <span class="keyword">null</span>;</span><br><span class="line">     DoubleNode next = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">         next = head.next;<span class="comment">//next标记当前节点后的链表，防止后续链表丢失</span></span><br><span class="line">         head.next = pre;</span><br><span class="line">         head.last = next;<span class="comment">//反转指针</span></span><br><span class="line">         pre = head;</span><br><span class="line">         head = next;<span class="comment">//移动pre head</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> pre;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h2 id="用单链表实现队列和栈"><a href="#用单链表实现队列和栈" class="headerlink" title="用单链表实现队列和栈"></a>用单链表实现队列和栈</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> V value;</span><br><span class="line">        <span class="keyword">public</span> Node&lt;V&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-用单链表结构实现队列结构"><a href="#1-用单链表结构实现队列结构" class="headerlink" title="1.用单链表结构实现队列结构"></a>1.用单链表结构实现队列结构</h4><p>队列结构先进先出；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> Node&lt;V&gt; head;</span><br><span class="line">       <span class="keyword">private</span> Node&lt;V&gt; tail;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//构造方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           head = <span class="keyword">null</span>;</span><br><span class="line">           tail = <span class="keyword">null</span>;</span><br><span class="line">           size = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//判断是否为空</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//返回队列的长度</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> size;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//入队列</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">           Node&lt;V&gt; cur = <span class="keyword">new</span> Node&lt;&gt;(v);</span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">               head = cur;</span><br><span class="line">               tail = cur;</span><br><span class="line">               size++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               tail.next = cur;</span><br><span class="line">               tail = tail.next;</span><br><span class="line">               size++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//出队列</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> V <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           V ans = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ans = head.value;</span><br><span class="line">               ;</span><br><span class="line">               head = head.next;</span><br><span class="line">               size--;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ans;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取队列的长度</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> V <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           V ans = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               ans = head.value;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> ans;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-用单链表结构实现栈结构"><a href="#2-用单链表结构实现栈结构" class="headerlink" title="2.用单链表结构实现栈结构"></a>2.用单链表结构实现栈结构</h4><p>栈结构后进先出；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">           <span class="keyword">private</span> Node&lt;V&gt; head;</span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//构造函数</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               head = <span class="keyword">null</span>;</span><br><span class="line">               size = <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//判断是否为空</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//获取栈的长度</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> size;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//入栈</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">               Node&lt;V&gt; cur = <span class="keyword">new</span> Node&lt;&gt;(v);</span><br><span class="line">               <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   head = cur;</span><br><span class="line">                   size++;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   cur.next = head;</span><br><span class="line">                   head = cur;</span><br><span class="line">                   size++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//出栈</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> V <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               V ans = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   ans = head.value;</span><br><span class="line">                   head = head.next;</span><br><span class="line">                   size--;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> ans;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//获取栈顶的值</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> V <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               V ans = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   ans = head.value;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> ans;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 时间复杂度都是O(1)</p>
</blockquote>
<h2 id="用双端链表实现双端队列"><a href="#用双端链表实现双端队列" class="headerlink" title="用双端链表实现双端队列"></a>用双端链表实现双端队列</h2><p>双端队列只能通过双端链表实现</p>
<p>双端队列：可以头进尾出，也可以尾进头出；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//双链表节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> V value;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;V&gt; last;</span><br><span class="line">    <span class="keyword">public</span> Node&lt;V&gt; next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双端队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDeque</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;V&gt; head;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;V&gt; tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        head = <span class="keyword">null</span>;</span><br><span class="line">        tail = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从头入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushHead</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        Node&lt;V&gt; cur = <span class="keyword">new</span> Node&lt;&gt;(v);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = cur;</span><br><span class="line">            tail = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.next = head;</span><br><span class="line">            head.last = cur;</span><br><span class="line">            head = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从尾入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushTail</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">        Node&lt;V&gt; cur = <span class="keyword">new</span> Node&lt;&gt;(v);</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = cur;</span><br><span class="line">            tail = cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.next = cur;</span><br><span class="line">            cur.last = tail;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从头出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">pollHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        V ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = head.value;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123; <span class="comment">//出完最后一个节点，head和tail都为null，如果不手动调整tail的值，会造成脏数据</span></span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            head.last = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从尾出队列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">pollTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        V ans = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = tail.value;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail = tail.last;</span><br><span class="line">            tail.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取头部的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">peekHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        V ans=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ans=head.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取尾部的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V  <span class="title">peekTail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        V ans=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ans=tail.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="K个节点组内的逆序调整"><a href="#K个节点组内的逆序调整" class="headerlink" title="K个节点组内的逆序调整"></a>K个节点组内的逆序调整</h2><p>给定一个单链表的头节点，和一个正整数K，实现K个节点的小组内部逆序，如果最后一组不够k个就不调整</p>
<p>例子： 调整前：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7-&gt;8,k=3   调整后：3-&gt;2-&gt;1-&gt;6-&gt;5-&gt;4-&gt;7-&gt;8</p>
<blockquote>
<p>链表考细心，链表不过很容易被pass</p>
</blockquote>
<blockquote>
<p>//leetcode链接：<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">https://leetcode.com/problems/reverse-nodes-in-k-group/</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//leetcode链接：https://leetcode.com/problems/reverse-nodes-in-k-group/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code04_ReverseNodeslnKGroup_01</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不要提交评判</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> ListNode next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.找出一组数，start~end;如果剩下的数不够一组，直接返回head</span></span><br><span class="line">        <span class="comment">//2.反转该组数，lastEnd标记该数组的结尾节点start</span></span><br><span class="line">        <span class="comment">//3.根据lastEnd找到下一个start，重复步骤1；如果lastEnd之后没有下一组，结束循环</span></span><br><span class="line">        ListNode start = head;</span><br><span class="line">        ListNode end = getKGroupEnd(start, k);</span><br><span class="line">        <span class="keyword">if</span> (end == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一组凑齐了</span></span><br><span class="line">        head = end;</span><br><span class="line">        reverse(start, end);</span><br><span class="line">        <span class="comment">//上一组的结尾节点</span></span><br><span class="line">        ListNode lastEnd = start;</span><br><span class="line">        <span class="keyword">while</span> (lastEnd.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            start = lastEnd.next;</span><br><span class="line">            end = getKGroupEnd(start, k);</span><br><span class="line">            <span class="keyword">if</span> (end == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(start, end);</span><br><span class="line">            lastEnd.next = end;</span><br><span class="line">            lastEnd = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">getKGroupEnd</span><span class="params">(ListNode start, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (--k != <span class="number">0</span> &amp;&amp; start != <span class="keyword">null</span>) &#123;</span><br><span class="line">            start = start.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(ListNode start, ListNode end)</span> </span>&#123;</span><br><span class="line">        end = end.next;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = start;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;  <span class="comment">//cur=cur.ext == cur=pre ×</span></span><br><span class="line">        &#125;</span><br><span class="line">        start.next = end; <span class="comment">//反转后的链表和后面的链表链接，不要忘记！！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="两个链表相加"><a href="#两个链表相加" class="headerlink" title="两个链表相加"></a>两个链表相加</h2><p>给定两个链表的头节点head1和head2，认为从左到右是某个数字从低位到高位，返回相加之后的链表</p>
<p>例子  4-&gt;3-&gt;6  2-&gt;5-&gt;3</p>
<p>返回  6-&gt;8-&gt;9</p>
<p>634+352=986</p>
<p>链表相加可以分三个阶段进行，如图所示：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220105204450967.png" alt="链表相加"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = listLength(head1);</span><br><span class="line">        <span class="keyword">int</span> len2 = listLength(head2);</span><br><span class="line">        ListNode l = len1 &gt; len2 ? head1 : head2; <span class="comment">//标记长链</span></span><br><span class="line">        ListNode s = l == head1 ? head2 : head1;  <span class="comment">//标记短链</span></span><br><span class="line">        ListNode curL = l;</span><br><span class="line">        ListNode curS = s;</span><br><span class="line">        ListNode last = curL;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">int</span> curNum = <span class="number">0</span>; <span class="comment">//当前计算结果</span></span><br><span class="line">        <span class="keyword">while</span> (curL != <span class="keyword">null</span>) &#123;  <span class="comment">//第一阶段：长链+短链+进位</span></span><br><span class="line">            curNum = curL.val + curS.val + carry;</span><br><span class="line">            carry = curNum / <span class="number">10</span>;</span><br><span class="line">            curL.val = curNum % <span class="number">10</span>;</span><br><span class="line">            last = curL;</span><br><span class="line">            curL = curL.next;</span><br><span class="line">            curS = curS.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curS != <span class="keyword">null</span>) &#123; <span class="comment">//第二阶段：长链+进位</span></span><br><span class="line">            curNum = curL.val + carry;</span><br><span class="line">            carry = curNum / <span class="number">10</span>;</span><br><span class="line">            curL.val = curNum % <span class="number">10</span>;</span><br><span class="line">            last = curL;</span><br><span class="line">            curL = curL.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>) &#123; <span class="comment">//第三阶段：进位</span></span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">            last.next = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">listLength</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="有序链表合并"><a href="#有序链表合并" class="headerlink" title="有序链表合并"></a>有序链表合并</h2><p>给定两个有序链表的头节点head1和head2，返回合并之后的大链表，要求依然有序。</p>
<p>例子 1-&gt;3-&gt;3-&gt;5-&gt;7  2-&gt;2-&gt;3-&gt;3-&gt;7</p>
<p>返回 1-&gt;2-&gt;2-&gt;3-&gt;3-&gt;3-&gt;5-&gt;7</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 测试链接：https://leetcode.com/problems/merge-two-sorted-lists</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不要提交这个类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> ListNode next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeTwoSortedLinkedList</span><span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="keyword">null</span> || head2 == <span class="keyword">null</span>) &#123;  <span class="comment">//边界条件</span></span><br><span class="line">            <span class="keyword">return</span> head1 == <span class="keyword">null</span> ? head2 : head1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = head1.val &lt; head2.val ? head1 : head2; <span class="comment">//含有最小值的链表头节点作为合并链表头节点</span></span><br><span class="line">        ListNode cur1 = head.next;</span><br><span class="line">        ListNode cur2 = head == head1 ? head2 : head1;</span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="keyword">null</span> &amp;&amp; cur2 != <span class="keyword">null</span>) &#123; <span class="comment">//依次将当前最小值串联起来</span></span><br><span class="line">            <span class="keyword">if</span> (cur1.val &lt;= cur2.val) &#123; </span><br><span class="line">                pre.next = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = cur1 == <span class="keyword">null</span> ? cur2 : cur1;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>异或运算</title>
    <url>/2021/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="异或运算的性质"><a href="#异或运算的性质" class="headerlink" title="异或运算的性质"></a>异或运算的性质</h2><p>1）0^N=N</p>
<p>2）N^N=0</p>
<p>3）满足交换律结合律：a^b=b^a  (a^b)^c=a^(b^c)</p>
<p>​    偶数个1异或 = 0  ==&gt; 偶数个相同的数异或 = 0</p>
<p>​    奇数个1异或 = 1 ==&gt; 奇数个相同的数异或 = 原来的数</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1-不需要第三个变量即完成两个值的交换："><a href="#1-不需要第三个变量即完成两个值的交换：" class="headerlink" title="1. 不需要第三个变量即完成两个值的交换："></a>1. 不需要第三个变量即完成两个值的交换：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// a = 甲；b = 乙</span><br><span class="line">a = a ^ b // a = 甲 ^ 乙</span><br><span class="line">b = a ^ b // b = 甲 ^ 乙 ^ 乙 = 甲</span><br><span class="line">a = a ^ b // a =  甲 ^ 乙 ^ 甲 = 乙</span><br></pre></td></tr></table></figure>

<p><strong>需要满足的条件：a和b必须指向不同的内存区域，否则异或运算之后a和b都为0</strong>；如果没法在上游保证a b分别指向不同的内存区域，还是老实写交换代码吧。 </p>
<p>虽然位运算的效率更高，但是和交换变量的代码效率差别不大。</p>
<h3 id="2-一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"><a href="#2-一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数" class="headerlink" title="2. 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数"></a>2. 一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数</h3><p>根据异或运算的特点，出现偶数次的数异或之后为0，出现奇数次的数异或之后为1，将所有这个数的数组进行异或运算，即可得到奇数次的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arr中，只有一种数，出现奇数次</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		eor ^= arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(eor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-怎么把一个int类型的数，提取出最右侧的1来"><a href="#3-怎么把一个int类型的数，提取出最右侧的1来" class="headerlink" title="3.怎么把一个int类型的数，提取出最右侧的1来"></a>3.怎么把一个int类型的数，提取出最右侧的1来</h3><p>a &amp; （-a）&lt;==&gt; a &amp; ( ~ a + 1 ) </p>
<p>举个例子:</p>
<p> a = 0 1 1 0 1 1 1 0 0 1 0 0 0 0</p>
<p>~a = 1 0 0 1 0 0 0 1 1 0 1 1 1 1 </p>
<p>​                                  🔺 //~a 左边的数取反，本身的1打散</p>
<p>~a+1 =  1 0 0 1 0 0 0 1 1 1 0 0 0</p>
<p>​                                  🔺 //~a+1 还原原来的1</p>
<h3 id="4-一个数组中有两种数出现了奇数次，其他数出现了偶数次，怎么找到并打印这两种数"><a href="#4-一个数组中有两种数出现了奇数次，其他数出现了偶数次，怎么找到并打印这两种数" class="headerlink" title="4.一个数组中有两种数出现了奇数次，其他数出现了偶数次，怎么找到并打印这两种数"></a>4.一个数组中有两种数出现了奇数次，其他数出现了偶数次，怎么找到并打印这两种数</h3><p>1)所有数进行异或，只剩下出现奇数次的两个数的异或值 eor=a^b</p>
<p><strong>2)eor提取出最右侧的1；数组的数可以分为两类，一类是与eor出现1位次也同样出现1的数，一共有a+偶数个；一类是与eor出现1位次出现0的数，一共有b+偶数个；</strong></p>
<p>3)异或第一类数，可以得到 a；得到a之后通过eor^a=a^b^a=b</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arr中，有两种数，出现奇数次</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			eor ^= arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// eor != 0  eor = a^b</span></span><br><span class="line">		<span class="comment">// eor最右侧的1，提取出来</span></span><br><span class="line">		<span class="comment">// eor :     00110010110111000</span></span><br><span class="line">		<span class="comment">// rightOne :00000000000001000</span></span><br><span class="line">		<span class="keyword">int</span> rightOne = eor &amp; (-eor); <span class="comment">// 提取出最右的1</span></span><br><span class="line">		<span class="keyword">int</span> onlyOne = <span class="number">0</span>; <span class="comment">// eor&#x27;</span></span><br><span class="line">		<span class="comment">// 只和rightOne同样位数出现1的数相与，剩下一个出现奇数次的数a</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length;i++) &#123;</span><br><span class="line">			<span class="comment">//  arr[1] =  111100011110000</span></span><br><span class="line">			<span class="comment">// rightOne=  000000000010000</span></span><br><span class="line">			<span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">				onlyOne ^= arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 另一个出现奇数次的数 a ^ a ^ b == b</span></span><br><span class="line">		System.out.println(onlyOne + <span class="string">&quot; &quot;</span> + (eor ^ onlyOne));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-一个数组中有一种数出现K次，其他数都出现了M次；M-gt-1-K-lt-M-找到出现了K次的数，要求额外空间复杂度O-1-时间复杂度O-N"><a href="#5-一个数组中有一种数出现K次，其他数都出现了M次；M-gt-1-K-lt-M-找到出现了K次的数，要求额外空间复杂度O-1-时间复杂度O-N" class="headerlink" title="5.一个数组中有一种数出现K次，其他数都出现了M次；M&gt;1,K&lt;M;找到出现了K次的数，要求额外空间复杂度O(1),时间复杂度O(N)"></a>5.一个数组中有一种数出现K次，其他数都出现了M次；M&gt;1,K&lt;M;找到出现了K次的数，要求额外空间复杂度O(1),时间复杂度O(N)</h3><p>将所有数进行异或运算，那么某一位出现1的次数位m次或者m+k次，只要找到1出现m+k次的位数，即可还原出k出现的次数。</p>
<p>要求额外空间复杂度为O(N)，就是不能直接用mao存储数组中出现的数。</p>
<p>使用数组存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(N)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">onlyKTimesArry</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] t = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                t[i] += (num &gt;&gt; i) &amp; <span class="number">1</span>;   <span class="comment">// 统计 每个位1出现的次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[i] % m != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t[i] % m == k) &#123;  </span><br><span class="line">                    ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count != k) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>使用map存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个map用于存储 1在不同二进制位出现对应的数 的位置</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">onlyKTimesMap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (map.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           createMap(map);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span>[] t = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">           <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> rightOne = num &amp; (-num);</span><br><span class="line">               t[map.get(rightOne)]++;</span><br><span class="line">               num ^= rightOne;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (t[i] % m != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (t[i] % m == k) &#123;</span><br><span class="line">                   ans |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (ans == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">               <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">                   count++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">               <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Map&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">           map.put(value, i);</span><br><span class="line">           value &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度都为O(N)</p>
</blockquote>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>异或运算</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序和快速排序</title>
    <url>/2021/01/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="1-递归方式"><a href="#1-递归方式" class="headerlink" title="1.递归方式"></a>1.递归方式</h3><p>1）分割和归并两大步骤</p>
<p>2）归并的时候也会进行排序</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/v2-2958d4f3d9dd9156f1b5dca6788fe8a7_720w.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归方法实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// arr[L...R]范围上，请让这个范围上的数，有序！</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 分割</span></span><br><span class="line">		<span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// int mid = (L + R) / 2 : 这种方式下标太大容易越界</span></span><br><span class="line">		<span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); <span class="comment">//更安全</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//排序</span></span><br><span class="line">		process(arr, L, mid); <span class="comment">// 左边排序</span></span><br><span class="line">		process(arr, mid + <span class="number">1</span>, R); <span class="comment">// 右边排序</span></span><br><span class="line">		merge(arr, L, mid, R);<span class="comment">// 左右组merge</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> p1 = L;</span><br><span class="line">		<span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">			help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 要么p1越界，要么p2越界</span></span><br><span class="line">		<span class="comment">// 不可能出现：共同越界</span></span><br><span class="line">		<span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">			help[i++] = arr[p1++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">			help[i++] = arr[p2++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 把排序好的数复制回原数组</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">			arr[L + i] = help[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-非递归方式"><a href="#2-非递归方式" class="headerlink" title="2.非递归方式"></a>2.非递归方式</h3><p><img src="https://gitee.com/hhn060206/img/raw/master/img/72E2D9AC92BD895BD283994B415E1AE1.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> p1 = L;</span><br><span class="line">		<span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">			help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 要么p1越界，要么p2越界</span></span><br><span class="line">		<span class="comment">// 不可能出现：共同越界</span></span><br><span class="line">		<span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">			help[i++] = arr[p1++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">			help[i++] = arr[p2++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 把排序好的数复制回原数组</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">			arr[L + i] = help[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//时间复杂度 O(N*log2N)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> N = arr.length;</span><br><span class="line">		<span class="keyword">while</span> (step &lt; N) &#123;</span><br><span class="line">			<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (L &lt; N) &#123;</span><br><span class="line">				<span class="keyword">int</span> M = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// 左组</span></span><br><span class="line">				<span class="comment">// M = L + step - 1 有可能溢出，成为负值</span></span><br><span class="line">				<span class="keyword">if</span> (N - L &gt;= step) &#123; <span class="comment">// L...N-1;剩余数的个数N-1-L+1==&gt;N-L;step &lt; N-1-L+1，步长小于剩余数的个数</span></span><br><span class="line">					M = L + step - <span class="number">1</span>; <span class="comment">// 直接计算M即可</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;<span class="comment">// step &lt; N-1-L+1，步长大于剩余数的个数</span></span><br><span class="line">					M = N - <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// M到N-1，没有右组，不用排</span></span><br><span class="line">				<span class="keyword">if</span> (M == N - <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 右组</span></span><br><span class="line">				<span class="keyword">int</span> R = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (N - <span class="number">1</span> - M &gt;= step) &#123; <span class="comment">// M+1...N-1;剩余数的个数N-1-M-1+1==&gt; N-1-M;step&lt;N-1-M,步长小于剩余数的个数</span></span><br><span class="line">					R = M + step; <span class="comment">// R = M + 1 + step - 1</span></span><br><span class="line">				&#125; <span class="keyword">else</span> &#123; <span class="comment">// 步长大于剩余数的个数</span></span><br><span class="line">					R = N - <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				merge(arr, L, M, R);</span><br><span class="line">				<span class="comment">// 防止下一组的L越界</span></span><br><span class="line">				<span class="keyword">if</span> (R == N - <span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					L = R + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (step &gt; N / <span class="number">2</span>) &#123;  <span class="comment">//防止step越界：当step很大时，step*=2有可能&gt;N-1并且越界;不可以是step&gt;=N/2,当step=N/2时break，最后一步不调整</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			step *= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 非递归方法实现的另一种写法</span></span><br><span class="line"><span class="comment">// 非递归方法实现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> N = arr.length;</span><br><span class="line">		<span class="keyword">int</span> mergeSize = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (mergeSize &lt; N) &#123;</span><br><span class="line">			<span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (L &lt; N) &#123;</span><br><span class="line">				<span class="keyword">if</span> (mergeSize &gt;= N - L) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">int</span> R = M + Math.min(mergeSize, N - M - <span class="number">1</span>);</span><br><span class="line">				merge(arr, L, M, R);</span><br><span class="line">				L = R + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mergeSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的问题：</strong></p>
<ol>
<li><p>step=2^n;</p>
</li>
<li><p>注意边界，有五个边界需要注意</p>
<p>① 左组边界M是否溢出</p>
<p>② 是否有右组</p>
<p>③ 右组边界R是否溢出</p>
<p>④ 下一组开头L=R+1是否溢出</p>
<p>⑤ step 是否越界</p>
</li>
<li><p>时间复杂度是O(log2N*N) </p>
</li>
</ol>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>递归方式</strong></p>
<p><strong>数组分层递归</strong></p>
<p>分层</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220116161900230.png" alt="image-20220116161900230"></p>
<ol>
<li>以数组最后一个数为标记值，左边从-1开始为小于标记值的区域，右边从N-1开始为大于标记值的区域；从数组第一个数开始和标记值比较</li>
<li>如果当前数&lt;标记值，当前数与小于区域下一个数进行交换，小于区域向前扩张一位数，当前数指向下一位数</li>
<li>如果当前数&gt;标记值，当前数与大于区域前一位数进行交换，大于区域向前扩张一位数，当前数指向不变</li>
<li>如果当前数=标记值，当前数指向下一位</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    process(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] equalE = partition(arr, L, R);</span><br><span class="line">    process(arr, L, equalE[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">    process(arr, equalE[<span class="number">1</span>] + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L...R]范围上，拿arr[R]做划分值，</span></span><br><span class="line"><span class="comment">// L....R &lt; = &gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">    <span class="keyword">int</span> lessR = L - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> moreL = R;</span><br><span class="line">    <span class="keyword">int</span> index = L;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; moreL) &#123; <span class="comment">// 当前值和大于区域边界碰撞，停止交换</span></span><br><span class="line">        <span class="keyword">if</span> (arr[index] &lt; arr[R]) &#123; <span class="comment">// 当前值小于标记值</span></span><br><span class="line">            swap(arr, ++lessR, index++);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &gt; arr[R]) &#123; <span class="comment">//当前值大于标记值</span></span><br><span class="line">            swap(arr, --moreL, index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前值等于标记值</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, moreL, R); <span class="comment">//左右区域划分完之后再交换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;lessR + <span class="number">1</span>, moreL&#125;; <span class="comment">// lessR+1和moreR交换，因为此时moreR位置上的值也是等于标记值的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>非递归方法</strong></p>
<p>使用栈做迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">int</span> L;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">int</span> R;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">          L = left;</span><br><span class="line">          R = right;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Stack&lt;Job&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();  <span class="comment">//定义一个工作栈</span></span><br><span class="line">      stack.push(<span class="keyword">new</span> Job(<span class="number">0</span>, arr.length - <span class="number">1</span>));</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty()) &#123; <span class="comment">//对工作栈内的所有数组进行分层</span></span><br><span class="line">          Job cur = stack.pop();</span><br><span class="line">          <span class="keyword">int</span>[] equals = partition(arr, cur.L, cur.R);</span><br><span class="line">          <span class="keyword">if</span> (equals[<span class="number">0</span>] &gt; cur.L) &#123; <span class="comment">// 有&lt; 区域,创建一个子任务入栈</span></span><br><span class="line">              stack.push(<span class="keyword">new</span> Job(cur.L, equals[<span class="number">0</span>] - <span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (equals[<span class="number">1</span>] &lt; cur.R) &#123; <span class="comment">// 有 &gt; 区域,创建一个子任务入栈</span></span><br><span class="line">              stack.push(<span class="keyword">new</span> Job(equals[<span class="number">1</span>] + <span class="number">1</span>, cur.R));</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// arr[L...R]范围上，拿arr[R]做划分值，</span></span><br><span class="line">  <span class="comment">// L....R &lt; = &gt;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R) &#123;</span><br><span class="line">      <span class="keyword">int</span> lessR = L - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> moreL = R;</span><br><span class="line">      <span class="keyword">int</span> index = L;</span><br><span class="line">      <span class="keyword">while</span> (index &lt; moreL) &#123; <span class="comment">// 当前值和大于区域边界碰撞，停止交换</span></span><br><span class="line">          <span class="keyword">if</span> (arr[index] &lt; arr[R]) &#123; <span class="comment">// 当前值小于标记值</span></span><br><span class="line">              swap(arr, ++lessR, index++);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &gt; arr[R]) &#123; <span class="comment">//当前值大于标记值</span></span><br><span class="line">              swap(arr, --moreL, index);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前值等于标记值</span></span><br><span class="line">              index++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(arr, moreL, R); <span class="comment">//左右区域划分完之后再交换</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;lessR + <span class="number">1</span>, moreL&#125;; <span class="comment">// lessR+1和moreR交换，因为此时moreR位置上的值也是等于标记值的</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">      arr[i] = arr[j];</span><br><span class="line">      arr[j] = tmp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>归并排序 快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>评估算法优劣的核心指标</title>
    <url>/2021/01/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%AF%84%E4%BC%B0%E7%AE%97%E6%B3%95%E4%BC%98%E5%8A%A3%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h2 id="评估算法优劣的核心指标是什么？"><a href="#评估算法优劣的核心指标是什么？" class="headerlink" title="评估算法优劣的核心指标是什么？"></a>评估算法优劣的核心指标是什么？</h2><h3 id="1-时间复杂度（流程决定）"><a href="#1-时间复杂度（流程决定）" class="headerlink" title="1.时间复杂度（流程决定）"></a>1.时间复杂度（流程决定）</h3><h4 id="常数操作-固定时间的操作"><a href="#常数操作-固定时间的操作" class="headerlink" title="常数操作:固定时间的操作"></a>常数操作:固定时间的操作</h4><p>例如：a+b；123+234；a[i]；a[1]等等</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220118232810362.png" alt="image-20220118232810362"></p>
<p><strong>时间复杂的分析要精确到常数时间的操作</strong></p>
<p>选择排序O(n^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minValueIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                minValueIndex = arr[j] &lt; arr[i] ? j : i;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, minValueIndex, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> j, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>冒泡排序O(n^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 0 ~ N-1</span></span><br><span class="line">		<span class="comment">// 0 ~ N-2</span></span><br><span class="line">		<span class="comment">// 0 ~ N-3</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> e = arr.length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123; <span class="comment">// 0 ~ e</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">					swap(arr, i, i + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 交换arr的i和j位置上的值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		arr[i] = arr[i] ^ arr[j];</span><br><span class="line">		arr[j] = arr[i] ^ arr[j];</span><br><span class="line">		arr[i] = arr[i] ^ arr[j];</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>插入排序O(n^2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不只1个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123; <span class="comment">// 0 ~ i 做到有序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123; <span class="comment">// j&gt;=0要放在&amp;&amp;前优先考虑，否则很有可能会溢出</span></span><br><span class="line">                swap(arr, j, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220118235843925.png" alt="image-20220118235843925"></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220119000010733.png" alt="image-20220119000010733"></p>
<h4 id="时间复杂度的意义"><a href="#时间复杂度的意义" class="headerlink" title="时间复杂度的意义"></a>时间复杂度的意义</h4><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220119000034440.png" alt="image-20220119000034440"></p>
<h4 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h4><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220119001410571.png" alt="image-20220119001410571"></p>
<h3 id="2-额外空间复杂度"><a href="#2-额外空间复杂度" class="headerlink" title="2.额外空间复杂度"></a>2.额外空间复杂度</h3><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220119000554884.png" alt="image-20220119000554884"></p>
<p>额外空间：用户完成功能需要额外申请的空间（用户传入的参数和要求返回结果的空间不算）</p>
<p>有限个变量的额外空间复杂度O(1)</p>
<p>需要一个数组/HashMap的额外空间复杂度O(n)</p>
<h3 id="3-算法流程的常数项"><a href="#3-算法流程的常数项" class="headerlink" title="3.算法流程的常数项"></a>3.算法流程的常数项</h3><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220119000738518.png" alt="image-20220119000738518"></p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220119000943477.png" alt="image-20220119000943477"></p>
<h2 id="面试、比赛、刷题中，一个问题的最优解是什么意思？"><a href="#面试、比赛、刷题中，一个问题的最优解是什么意思？" class="headerlink" title="面试、比赛、刷题中，一个问题的最优解是什么意思？"></a>面试、比赛、刷题中，一个问题的最优解是什么意思？</h2><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220119001237013.png" alt="image-20220119001237013"></p>
<h2 id="算法和数据结构学习的大脉络"><a href="#算法和数据结构学习的大脉络" class="headerlink" title="算法和数据结构学习的大脉络"></a>算法和数据结构学习的大脉络</h2><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220119001449776.png" alt="image-20220119001449776"></p>
<p>1和2在面试中占同等重要的比例</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>时间复杂度 额外空间复杂度 基本排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>比较器、优先队列、二叉树</title>
    <url>/2021/01/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%AF%94%E8%BE%83%E5%99%A8%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><h3 id="1-自定义的比较器"><a href="#1-自定义的比较器" class="headerlink" title="1.自定义的比较器"></a>1.自定义的比较器</h3><p>自定义的类无法通过直接调用Array.sort() / arrList.sort();进行排序，要使用Array.sort()对自定义的类的对象惊醒排序，需要传入一个自定义的比较器。</p>
<p>定义一个自定义的比较器，即需要一个实现<code>Comparator&lt;T&gt;</code>接口的类(T为自定义的类),同时重写compare()方法。</p>
<p>compare()方法返回值的规则：</p>
<blockquote>
<p>1.如果返回负数，认为第一个参数应该排在前面<br>2.如果返回正数，认为第二个参数应该排在前面<br>3.如果返回0，认为谁放前面无所谓</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> String name;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> id, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.name = name;</span><br><span class="line">			<span class="keyword">this</span>.id = id;</span><br><span class="line">			<span class="keyword">this</span>.age = age;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 谁id大，谁放前！</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IdComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果返回负数，认为第一个参数应该排在前面</span></span><br><span class="line">		<span class="comment">// 如果返回正数，认为第二个参数应该排在前面</span></span><br><span class="line">		<span class="comment">// 如果返回0，认为谁放前面无所谓</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (o1.id &lt; o2.id) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o2.id &lt; o1.id) &#123;</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 谁age大，谁放前！</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果返回负数，认为第一个参数应该排在前面</span></span><br><span class="line">		<span class="comment">// 如果返回正数，认为第二个参数应该排在前面</span></span><br><span class="line">		<span class="comment">// 如果返回0，认为谁放前面无所谓</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (o1.age &lt; o2.age) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (o2.age &lt; o1.age) &#123;</span><br><span class="line">				<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个student数组</span></span><br><span class="line">Arrays.sort(students, <span class="keyword">new</span> IdComparator());</span><br><span class="line"><span class="comment">//创建一个student链表</span></span><br><span class="line">arrList.sort(<span class="keyword">new</span> AgeComparator());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-有序结构定义自定义比较器"><a href="#2-有序结构定义自定义比较器" class="headerlink" title="2.有序结构定义自定义比较器"></a>2.有序结构定义自定义比较器</h3><p>优先队列、treeMap、treeSet等有序结构都可以自定义比较器来对自定义的类的对象进行比较。例如优先队列可以调用上面的id比较器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//id大的学生在前</span></span><br><span class="line">PriorityQueue&lt;Student&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> IdComparator());</span><br></pre></td></tr></table></figure>

<blockquote>
<p>优先队列：小根堆，默认值小的对象在前。</p>
</blockquote>
<h3 id="3-字符串如何比较大小？"><a href="#3-字符串如何比较大小？" class="headerlink" title="3.字符串如何比较大小？"></a>3.字符串如何比较大小？</h3><p>所有变成语言中，字符串都是使用<strong>字典序</strong>比较大小的。</p>
<blockquote>
<p><strong>字典序</strong></p>
<p>1.相同长度的字符串：比较每个字符的ASCII码，ACSII码小的字符串较小。</p>
<p>2.不同长度的字符串：较短的字符串使用ASCII码0补全至长度和较长的字符串一致，再根据ACSII码进行比较。</p>
</blockquote>
<h3 id="4-合并K个升序链表"><a href="#4-合并K个升序链表" class="headerlink" title="4.合并K个升序链表"></a>4.合并K个升序链表</h3><p>leetcode链接：<a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">https://leetcode-cn.com/problems/merge-k-sorted-lists/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china</a></p>
<ol>
<li>这道题可以使用优先队列来弹出当前的最小值；</li>
<li>要利用这一特性，我们就要创建一个优先队列来存放每个链表的头节点，首先弹出一个最小值作为新链表的头节点，再将弹出节点的下一个节点加入小根堆，直到小根堆里没有节点为止。</li>
<li>优先队列的比较器可以自定义</li>
</ol>
<p><strong>比较器 |优先队列 | 边界条件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code01_MergeKSortedLists</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> val;</span><br><span class="line">		<span class="keyword">public</span> ListNode next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNodeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">ListNode</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(ListNode o1, ListNode o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.val - o2.val; </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (lists == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		PriorityQueue&lt;ListNode&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> ListNodeComparator());</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">			<span class="comment">//边界条件</span></span><br><span class="line">			<span class="keyword">if</span> (lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">				heap.add(lists[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//边界条件</span></span><br><span class="line">		<span class="keyword">if</span> (heap.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//小根堆弹出一个作为返回链表的头节点,进入头节点指向的下一个</span></span><br><span class="line">		ListNode head = heap.poll();</span><br><span class="line">		ListNode pre = head;</span><br><span class="line">		<span class="keyword">if</span> (pre.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">			heap.add(pre.next);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!heap.isEmpty()) &#123; <span class="comment">//直到小根堆为空</span></span><br><span class="line">			<span class="comment">//弹出一个</span></span><br><span class="line">			ListNode cur = heap.poll();</span><br><span class="line">			<span class="comment">//加入链表</span></span><br><span class="line">			pre.next = cur;</span><br><span class="line">			pre = cur;</span><br><span class="line">			<span class="keyword">if</span> (cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//加入一个</span></span><br><span class="line">				heap.add(cur.next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="1-二叉树不能有环"><a href="#1-二叉树不能有环" class="headerlink" title="1. 二叉树不能有环"></a>1. 二叉树不能有环</h3><h3 id="2-三种遍历方式"><a href="#2-三种遍历方式" class="headerlink" title="2. 三种遍历方式"></a>2. 三种遍历方式</h3><p>(1)先序遍历：头节点，左节点，右节点</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112152349997.png" alt="image-20220112152349997"></p>
<p>(2)中序遍历：左节点、头节点、右节点</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112152447127.png" alt="image-20220112152447127"></p>
<p>(3)后序遍历：左节点、右节点、头节点</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112152524169.png" alt="image-20220112152524169"></p>
<h3 id="3-递归序与先序、中序、后序"><a href="#3-递归序与先序、中序、后序" class="headerlink" title="3. 递归序与先序、中序、后序"></a>3. 递归序与先序、中序、后序</h3><p><strong>递归序：递归程序遍历节点的顺序</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第一次回到最小树的头节点  在这里System.out.println(head.value),是先序遍历</span></span><br><span class="line">    f(node.left);</span><br><span class="line">    <span class="comment">//第二次回到最小树的头节点  在这里System.out.println(head.value)，是中序遍历</span></span><br><span class="line">    f(node.right);</span><br><span class="line">    <span class="comment">//第三次回到最小树的头节点  在这里System.out.println(head.value)，是后序遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归程序遍历二叉树①的顺序如图②所示，图③则为其递归序：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112153918244.png" alt="image-20220112153918244"></p>
<p><strong>递归序和先序遍历、中序遍历、后序遍历的结果有什么关系？</strong></p>
<p>先序遍历：数字第一次出现就打印，即小数头节点出现第一次时就打印头节点。</p>
<p>中序遍历：数字第二次出现就打印，即小数头节点出现第二次时就打印头节点。</p>
<p>后序遍历：数字第三次出现就打印，即小数头节点出现第三次时就打印头节点。</p>
<h3 id="4-二叉树的相关题目"><a href="#4-二叉树的相关题目" class="headerlink" title="4.二叉树的相关题目"></a>4.二叉树的相关题目</h3><h5 id="（1）相同的树"><a href="#（1）相同的树" class="headerlink" title="（1）相同的树"></a>（1）相同的树</h5><p>leetcode：<a href="https://leetcode-cn.com/problems/same-tree/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china">https://leetcode-cn.com/problems/same-tree/?utm_source=LCUS&amp;utm_medium=ip_redirect&amp;utm_campaign=transfer2china</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断是否一棵树为空，另一棵不为空</span></span><br><span class="line">		<span class="keyword">if</span> (p == <span class="keyword">null</span> ^ q == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断两棵树是否都为空</span></span><br><span class="line">		<span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 都不为空</span></span><br><span class="line">		<span class="comment">// 头节点值相同，左子树和右子书分别相同</span></span><br><span class="line">		<span class="keyword">return</span> p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（2）镜面树"><a href="#（2）镜面树" class="headerlink" title="（2）镜面树"></a>（2）镜面树</h5><p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112161107290.png" alt="左节点的左子树和右节点的右子树互为镜面，左节点的右子树和右节点的左子树互为镜面"></p>
<p>leetcode：<a href="https://leetcode.com/problems/symmetric-tree">https://leetcode.com/problems/symmetric-tree</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//头节点自己和自己对比</span></span><br><span class="line">		<span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对比两棵树是否是镜面的</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode h1, TreeNode h2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (h1 == <span class="keyword">null</span> ^ h2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (h1 == <span class="keyword">null</span> &amp;&amp; h2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//两棵树都不为空</span></span><br><span class="line">		<span class="comment">//镜面树：左节点的左子树和右节点的右子树互为镜面，左节点的右子树和右节点的左子树互为镜面</span></span><br><span class="line">		<span class="keyword">return</span> h1.val == h2.val &amp;&amp; isMirror(h1.left, h2.right) &amp;&amp; isMirror(h1.right, h2.left);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-返回树的最大高度"><a href="#3-返回树的最大高度" class="headerlink" title="(3)返回树的最大高度"></a>(3)返回树的最大高度</h5><p>leetcode:<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree">https://leetcode.com/problems/maximum-depth-of-binary-tree</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以root为头的树，最大高度是多少返回！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-通过先序数组和中序数组重建二叉树"><a href="#4-通过先序数组和中序数组重建二叉树" class="headerlink" title="(4)通过先序数组和中序数组重建二叉树"></a>(4)通过先序数组和中序数组重建二叉树</h5><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal</a></p>
<p><strong>先序数组和中序数组的元素都是不重复的</strong></p>
<p>如何通过先序数组和中序数组重建二叉树？</p>
<p>①先序数组的第一个节点即为头节点；</p>
<p>②在中序数组中找到头节点，左侧的为左子树元素，右侧的为右子树元素；</p>
<p>③先序数组中可以找到对应的左子树元素对应和右子树元素分别对应的区间，区间的第一个元素即为头节点；重复②③步。</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112172926624.png" alt="如何通过先序数组和中序数组重建二叉树？"></p>
<p>在中序数组中找到头节点，确定左子树元素后，如何确定先序数组左子树元素的区间？</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112173151771.png" alt="确定先序数组左子树元素的区间1"></p>
<p>即L1+1向右走find-1 - L2长度</p>
<p>举个例子就可以发现：</p>
<p><img src="https://gitee.com/hhn060206/img/raw/master/img/image-20220112173230553.png" alt="确定先序数组左子树元素的区间"></p>
<p>新区间范围应该是L1 ~ L1+find-L2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//树节点结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> val;</span><br><span class="line">		TreeNode left;</span><br><span class="line">		TreeNode right;</span><br><span class="line"></span><br><span class="line">		TreeNode(<span class="keyword">int</span> val) &#123;</span><br><span class="line">			<span class="keyword">this</span>.val = val;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree1</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//先序数组为空、中序数组为空、中序数组先序数组长度不相等</span></span><br><span class="line">   <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length != in.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> f(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一棵树，先序结果是pre[L1...R1]，中序结果是in[L2...R2]</span></span><br><span class="line"><span class="comment">// 请建出整棵树返回头节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">f</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span>[] in, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//左数为空或者右树为空</span></span><br><span class="line">   <span class="keyword">if</span> (L1 &gt; R1) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//只有一个节点，返回这个节点即可</span></span><br><span class="line">   TreeNode head = <span class="keyword">new</span> TreeNode(pre[L1]);</span><br><span class="line">   <span class="keyword">if</span> (L1 == R1) &#123;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">int</span> find = L2;</span><br><span class="line">   <span class="comment">//遍历找到中序数组中头节点对应的位置</span></span><br><span class="line">   <span class="keyword">while</span> (in[find] != pre[L1]) &#123;</span><br><span class="line">      find++;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//确定左子树的先序数组、中序数组，右子树的先序数组、中序数组，递归</span></span><br><span class="line">   head.left = f(pre, L1 + <span class="number">1</span>, L1 + find - L2, in, L2, find - <span class="number">1</span>);</span><br><span class="line">   head.right = f(pre, L1 + find - L2 + <span class="number">1</span>, R1, in, find + <span class="number">1</span>, R2);</span><br><span class="line">   <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以空间换时间，用表记录中序数组每个元素出现的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">buildTree2</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length != in.length) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//一张表，记录中序数组中每一个值所在的位置</span></span><br><span class="line">		HashMap&lt;Integer, Integer&gt; valueIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">			valueIndexMap.put(in[i], i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> g(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>, valueIndexMap);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有一棵树，先序结果是pre[L1...R1]，中序结果是in[L2...R2]</span></span><br><span class="line">	<span class="comment">// 请建出整棵树返回头节点</span></span><br><span class="line">	<span class="comment">//空间换时间，时间复杂度O(n)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">g</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> L1, <span class="keyword">int</span> R1, <span class="keyword">int</span>[] in, <span class="keyword">int</span> L2, <span class="keyword">int</span> R2,</span></span></span><br><span class="line"><span class="params"><span class="function">			HashMap&lt;Integer, Integer&gt; valueIndexMap)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (L1 &gt; R1) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		TreeNode head = <span class="keyword">new</span> TreeNode(pre[L1]);</span><br><span class="line">		<span class="keyword">if</span> (L1 == R1) &#123;</span><br><span class="line">			<span class="keyword">return</span> head;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//直接从表中获取中序数组中头节点的位置</span></span><br><span class="line">		<span class="keyword">int</span> find = valueIndexMap.get(pre[L1]);</span><br><span class="line">		head.left = g(pre, L1 + <span class="number">1</span>, L1 + find - L2, in, L2, find - <span class="number">1</span>, valueIndexMap);</span><br><span class="line">		head.right = g(pre, L1 + find - L2 + <span class="number">1</span>, R1, in, find + <span class="number">1</span>, R2, valueIndexMap);</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>二叉树 比较器 优先队列</tag>
      </tags>
  </entry>
</search>
